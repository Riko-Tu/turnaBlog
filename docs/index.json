[{"categories":["docker"],"content":"docker+微服务+jekins+gitlab+ci/cd 仓库：存储镜像的仓库 镜像：容器的模板，可通过镜像生成多个容器 容器：通过镜像实例化出多个容器 ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:0","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"一、帮助命令 1.0 版本检测 docker version 1.1 查看信息 docker info 1.1 查看命令 docker --help ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:1","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"二、镜像命令 1.0 查看镜像 docker images [param] param: -a 展示所有镜像（含中间层） -q 只展示镜像id -qa 只展示所有镜像的id --digests 显示镜像的摘要信息 --no-trunc 显示完整的镜像信息（完整的id信息） 1.1 搜索镜像 docker search [options] [imagesName] [options]: -s [number] 展示收藏数大于number的镜像 1.2 下载镜像 docker pull tomcat //默认最新版 1.3 删除镜像 docker rmi [imagesName/ID] //默认删除最新版 docker rmi [imagesName] [imagesName/ID] //删除多个 docker rmi -f $(docker images -qa) //删除全部 ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:2","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"三、容器命令 1.0 启动容器 docker run [options] IMAGE [CMD] [arg] [options]: --name=\"容器新名字\"：为容器指定一个名称 -d :后台运行容器，并返回容器id，也即启动守护石容器 -i:已交互模式运行容器，通常与-t同时使用 -t:为容器重新分配一个伪输入终端，通常与-i同时使用 -P:随机端口映射 -p：指定端口映射，有以下四种格式： docker run -it --name mycentos centoS //运行centoS,并进入centoS的终端，启动交互式容器 docker run -d centos //启动守护式容器 docker run -it -p 8888:8080 tomcat // 8888为docker端口，8080是tomcat端口 ---------------------------------------------------------------------------------- docker start [容器id] 1.1 查看容器 docker ps [param] [param]: -a :列出当前所有正在运行的容器+历史上运行过的 -l :显示最近创建的容器 -n :显示最近N个创建的容器 -q ：静默模式，只显示容器编号 --no-trunc： 不截断输出 1.2 退出容器 exit /容器停止并退出 ctrl +P+Q 容器不停止退出 1.3 启动已有容器 docker start [容器id/容器名] 1.4 重启容器 docker restart [容器id/容器名] 1.5 停止容器 docker stop [容器id/容器名] docker kill [容器id/容器名] //强制停止 1.6 删除容器 docker rm [容器id/容器名] docker rm -f [容器id/容器名] //可删除运行中容器 docker rm -f $(docker ps -a -q) 1.7 容器日志 docker logs -f -t -tail number [容器名/容器id] -t:加入时间戳 -f:跟随最新的日志打印 --tail:数字显示最后几条 1.8 查看容器内进程 docker top [容器名/容器id] 1.9 查看容器细节 docker inspect [容器名/容器id] 2.0 进入容器 docker attach [容器名/容器id] 2.1 容器外执行 docker exec -it [容器名/容器id] bashshell 例： docker exec -it centos cd /tmp 2.2 拷贝容器文件 docker cp [容器名/容器id]:[容器文件路径] [当前系统路径] 例： docker cp centos:/tmp/yum.log /root 2.3 生成镜像 docker commit -a=\"作者\" -m=\"描述信息\" [容器id] [新镜像名:版本号] 重启服务 service docker restart ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:3","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"四、镜像原理 ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:4","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"五、 容器数据卷 为保存容器的数据，进行持久性开发，共享存储主机与容器之间的数据 1.0 命令数据同步 docker run -it -v /主机目录：/容器内目录 镜像id docker run -it -v /containerData/centosData:/centosData centos //容器的文件夹与主机的文件夹变成共享文件夹 docker run -it /主机目录:命令:/容器目录 镜像id 1.1 dockerFile数据同步 a. 编写可执行的dockerfile文件 b. 构建dockerfile成为新的镜像 docker build -f [指定dockerfile文件] -t [ImageName] c. 可通过docker inspect [容器id] 查看默认与主机相连的共享文件 1.2 容器间传递共享 docker run -it --name [newcontainerName] --volums-from [runningContainerName] [imageName] //image为两个容器的镜像，通过镜像来启动一个newContainer，newContainer再与runningContainer数据互通 ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:5","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["docker"],"content":"六、dockerFile 1.0 语法格式 1. 指令必须大写 2. 语法按照从上到下执行 3. #表示注释 4. 每条指令都会创建一个新的镜像层，并对镜像进行提交 1.1 dockerfile构建过程 1. docker 从基础镜像运行一个容器 2. 执行一条指令并对容器做出修改 3. 执行类似docker commit的操作提交一个新的镜像 4. docker再基于刚提交的镜像运行一个新容器 5. 执行dockerfile中的下一条指令直到所有指令都执行完成 1.2 保留字指令 FROM：基础镜像，当前新镜像是基于哪个镜像 MAINTAINER：镜像维护者的姓名和邮箱地址 RUN：容器构建是需要运行的命令 EXPOSE：当前容器对外暴露的端口号 WORKDIR：指定在创建容器后，默认进入的目录路径 ENV：用来在构建镜像过程中设置环境变量 ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY：拷贝文件和目录到镜像中 VOLUME：容器数据卷，用户数据保存和持久化工作 CMD：指定一个容器启动时，需要运行的命令（有多个cmd指令时，只有最后一个生效，CMD会被docker run之后的参数替换） ENTRYPOINT：指定一个容器启动时，需要运行的命令（追加参数） ONBUILD：当构建一个被继承的dockerfile时运行命令，父镜像obnuild会被触发 1.3 语法案例 ","date":"2023-08-16","objectID":"/posts/docker/docker/:0:6","tags":["docker"],"title":"docker - 基础命令","uri":"/posts/docker/docker/"},{"categories":["git"],"content":"git ","date":"2023-08-16","objectID":"/posts/git/git/:0:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":".gitignore 文件 有时一些文件最好不要用 Git 去查。这通常是在不知名.gitignore的特殊文件中完成。你可以在github.com/github/gitignore找到细节的.gitignore文件模板。 需要特别注意的是： 1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件， ``对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 ","date":"2023-08-16","objectID":"/posts/git/git/:1:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"配置 对所有本地仓库的用户信息进行配置 $ git config --global user.name \"[name]\" 对你的提交操作设置关联的用户名 $ git config --global user.email \"[email address]\" 对你的提交操作设置关联的邮箱地址 $ git config --global color.ui auto 可以有帮助的彩色液晶输出 ","date":"2023-08-16","objectID":"/posts/git/git/:2:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"初始化git git rm -r --cached . //清除git所有缓存 ","date":"2023-08-16","objectID":"/posts/git/git/:2:1","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"创建仓库 当某物于一个新的仓库时，你很相似一次。 $ git init 在使用过git init命令后，使用以下命令将本地仓库与一个 GitHub 上的空仓库连接起来： $ git remote add origin [url] 将现有目录转换为一个 Git 仓库 $ git clone [url] 克隆（下载）一个已在 GitHub 上的仓库，包括所有的文件、分支和提交（提交） ","date":"2023-08-16","objectID":"/posts/git/git/:3:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"分支 分支是使用 Git 工作的一个部分git status。 $ git branch [branch-name] 创建一个新分支 $ git switch -c [branch-name] 切换到分支指定并更新工作目录（工作目录） $ git merge [branch] 将指定分支的历史合并到当前分支。这通常在拉取请求（PR）中完成，但也是一个重要的 Git 操作。 $ git branch -d [branch-name] 删除指定分支 ","date":"2023-08-16","objectID":"/posts/git/git/:4:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"进行更改 浏览并检查项目文件的发展 $ git log 当前版本的历史版本 $ git log --follow [file] 过去文件的版本历史，包括重例 $ git diff [first-branch]...[second-branch] 展示两个分支的内容千差万别 $ git show [commit] 输出指定提交的元数据和内容变化 $ git add [file] 将文件进行处理用于版本控制 $ git commit -m \"[descriptive message]\" 将文件时刻地记录在历史中 ","date":"2023-08-16","objectID":"/posts/git/git/:5:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"重做提交 清除错误和构建用于替换的历史 $ git reset [commit] 撤销所有[commit]后的提交，在本地保存更改 $ git reset --hard [commit] 放弃所有历史，改回指定提交。 小心！更改历史可能会带来不良后果。如果您需要更改 GitHub（谨慎）已提交的，请操作。如果您需要帮助，可访问github.community或联系支持（支持）。 ","date":"2023-08-16","objectID":"/posts/git/git/:6:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"同步更改 将你本地收藏与GitHub.com 上的远端同步 $ git fetch 下载远端追踪的所有历史 $ git merge 将远端分支合并到当前局部分支 $ git pull 将所有本地分支提交上传到 GitHub $ git push 使用来自GitHub上的对应远端分支的所有新提交更新你当前的本地工作分支。git pull的英文git fetch状语从句：git merge的结合 ","date":"2023-08-16","objectID":"/posts/git/git/:7:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"术语表 git : 一个开源的发行版本控制系统 GitHub : 一个和协作管理 Git 仓库的平台 commit 提交: 一个 Git 对象是你整个仓库的散光值 分支分支：一个较轻的可移动的提交分支 clone : 一个仓库的本地版本，包含所有提交和分支 远程远端：一个 GitHub 上的公共仓库，所有小组成员通过它来交换修改 fork : 一个另一个用户的 GitHub 上的仓库的副本 拉取请求：为了更好地和讨论上引入的差异，且具有验证、评论、集成测试等功能的地方的 HEAD：代表你当前的工作目录。使用git checkout可移动 HEAD 提交到不同的分支、标记（标签）或 ","date":"2023-08-16","objectID":"/posts/git/git/:8:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"本地 版本切换 git reset --hard HEAD^ //head^ head^^ 也是可把head改成commit号 ","date":"2023-08-16","objectID":"/posts/git/git/:9:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"分支 ","date":"2023-08-16","objectID":"/posts/git/git/:10:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"创建分支 git branch [分支名] ","date":"2023-08-16","objectID":"/posts/git/git/:10:1","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"查看本库已有分支 git branch -v ","date":"2023-08-16","objectID":"/posts/git/git/:10:2","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"切换分支 git checkout [分支名] ","date":"2023-08-16","objectID":"/posts/git/git/:10:3","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"合并分支 git merge [要合并过来的分支名] //切换到接受的分支执行 ","date":"2023-08-16","objectID":"/posts/git/git/:10:4","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"合并分支冲突 当两个分支的同一个文件同一处被修改后，合并两分支会产生冲突 第一步：打开产生冲突的文件 第二部：将冲突标记符号删除(此时可以直接保存提交)，并将文件修改到不产生冲突为止，保存退出 第三步：git add . （add添加到暂存区） 第四部： git commit -m \"日志信息\" （添加到本地库） 第五步： git merge [分支名] ","date":"2023-08-16","objectID":"/posts/git/git/:10:5","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"更改分支名 git branch -m [原分支名] [新分支名] ","date":"2023-08-16","objectID":"/posts/git/git/:10:6","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"远程库 ","date":"2023-08-16","objectID":"/posts/git/git/:11:0","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"连接 git remote add [仓库地址别名] 仓库地址 实例:git remote add origin git@github.com:Riko-Tu/test.git ","date":"2023-08-16","objectID":"/posts/git/git/:11:1","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"查看已连接 git remote -v ","date":"2023-08-16","objectID":"/posts/git/git/:11:2","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"推送 git push [仓库地址别名] [仓库的分支] tip: 1.该命令需要将推送用户邀请进入仓库团队后才可使用 2.如果仓库不存在该分支，则会在远程库自动创建该分支 ","date":"2023-08-16","objectID":"/posts/git/git/:11:3","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"强制推送 git push origin master -f //f表示force ","date":"2023-08-16","objectID":"/posts/git/git/:11:4","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"rebase拉取 git pull --rebase origin master ","date":"2023-08-16","objectID":"/posts/git/git/:11:5","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"克隆本地 git clone 仓库地址 作用： 1.自动创建origin的远程库别名 2.自动初始化为本地库 ","date":"2023-08-16","objectID":"/posts/git/git/:11:6","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"拉取代码：分步操作 git fetch [远程仓库] [分支名] //将远程代码拉取到本地，但不合并本地的代码 git checkout [远程仓库] [分支名] //切换到拉取下来的代码分支，查看代码内容，如果问题不大可以再合并代码 git merge [远程仓库/分支名] //将fetch的代码与本地库的代码合并 ","date":"2023-08-16","objectID":"/posts/git/git/:11:7","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"拉取代码：直接合并 git pull [远程仓库] [分支名] //pull 等于fetch +merge ","date":"2023-08-16","objectID":"/posts/git/git/:11:8","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["git"],"content":"origin branch修改时 更新本地库的分支名 git branch -m main master git fetch origin git branch -u origin/master master git remote set-head origin -a ","date":"2023-08-16","objectID":"/posts/git/git/:11:9","tags":["git"],"title":"git - 基础命令","uri":"/posts/git/git/"},{"categories":["golang"],"content":"介绍 ","date":"2023-08-16","objectID":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:1:0","tags":["golang","cron"],"title":"golang - cron 定时任务","uri":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["golang"],"content":"使用 ","date":"2023-08-16","objectID":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:2:0","tags":["golang","cron"],"title":"golang - cron 定时任务","uri":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["golang"],"content":"初始化 go get github.com/robfig/cron/v3 import ( \"github.com/robfig/cron/v3\" ) // CronConfig 定时脚本配置 type CronConfig struct { ID int `json:\"id\"` Spec string `json:\"spec\" gorm:\"size:64\" ` // cron表达式 ： 秒分时日月周 FuncName string `json:\"funcName\" gorm:\"size:64\"` // 函数名 Describe string `json:\"describe\" gorm:\"size:256\"` // 任务名 ServerName string `gorm:\"size:32\"` // 服务名 Status string `json:\"status\" gorm:\"size:32\"` // 有效; 无效 } // 任务函数 // PrintOne 打印一 func PrintOne() { cronTime := make(chan bool) go func() { time.Sleep(time.Minute) cronTime \u003c- true }() for { select { case \u003c-cronTime: return case \u003c-time.After(time.Second): fmt.Println(\"1\") } } } // 任务映射表 var taskMap = map[string]func(){ \"PrintOne\": PrintOne, } func TestTimingTask(t *testing.T) { tasks := []CronConfig{{ Spec: \"0 * * * * *\", // 每分钟第0秒时执行 FuncName: \"PrintOne\", Describe: \"循环打印1,一分钟\", }} // 初始化 jobs := cron.New(cron.WithSeconds()) // cron.WithSeconds() 配置cron表达式 for _, task := range tasks { // 添加任务 _, err := jobs.AddFunc(task.Spec, taskMap[task.FuncName]) if err != nil { log.Fatal(err) } } // 开始定时 jobs.Start() // 加载到内存中等待执行 time.Sleep(time.Hour) } ","date":"2023-08-16","objectID":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:2:1","tags":["golang","cron"],"title":"golang - cron 定时任务","uri":"/posts/golang/golang-corn-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["golang"],"content":"grpc开源框架 简介 a. 传输协会http 2.0 b. 采用protobuffer传输消息 c. 具备四种传输模式 http版本特性 http 1.0：提供长连接，请求回应的模式 短连接：一次连接只能发送一个请求；每个请求都要进行三次握手和四次挥手 长连接（发送ack包）：一次连接可以发送多个请求；请求为同步请求，阻塞后影响效果 http 1.1： piperline:一次连接并发多个请求；请求按顺序返回 http 2.0 ： stream: 乱序发送,乱序接收 http 具备安全连接机制： a. ssl: b. tls: protobuffer 跨语言 数据流小：传输时，只把value进行压缩传输 数据压缩快： grpc service API 1. unary api 一元普通模式 ： 一个请求一个响应 2.client stream api 客户端流模式 ： 多个请求一个响应，客户端任务繁重时使用 3.server stream api 服务端流 ： 一个请求多个响应，客户端任务繁重时使用 4.bidirectional stream api 双端流 ： 多个请求多个响应 ","date":"2023-08-16","objectID":"/posts/golang/grpc/:1:0","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"一、编译器安装 安装proto文件编译器 go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 tips:安装完后默认存储到gopath里的bin目录下 安装golangProto文件识别插件 打开goland编译器，打开插件搜索protocol buffers 点击安装 安装grpc包 go get google.golang.org/grpc tpis:建议使用go mod tidy ","date":"2023-08-16","objectID":"/posts/golang/grpc/:2:0","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"二、proto ","date":"2023-08-16","objectID":"/posts/golang/grpc/:3:0","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"创建proto文件 在goland文件中创建file类型文件后缀为.proto ","date":"2023-08-16","objectID":"/posts/golang/grpc/:3:1","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"编写proto文件 syntax = \"proto3\"; option go_package = \"./;admin\"; package admin; //------------------------------------------------------------------- message HelloReq { string Name =1; } message HelloRes{ string Order =1; } service Hello{ rpc GET(HelloReq) returns (HelloRes){} } ","date":"2023-08-16","objectID":"/posts/golang/grpc/:3:2","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"编译proto 方式一： protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative [proto文件路径] tips: 1. 使用后会在目标文件下生成pb.gp和grpc.pb.go文件 ​ 2. massge放在pb文件内；server和client放在grpc文件内 这种方式在服务实现时，必须在结构体内嵌入Unimplemented才算实现了接口 type Admin struct { person.UnimplementedPersonServer } 方式二： protoc --go_out=plugins=grpc:. [proto文件] tips：1. 在proto文件目录下执行命令，会在当前目录下生成一个pb.go文件 ​ 2. massge与server和client放在一个文件内 proto生成对应的主要代码 type HelloReq struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Name string `protobuf:\"bytes,1,opt,name=Name,proto3\" json:\"Name,omitempty\"` } type HelloClient interface { GET(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloRes, error) } type helloClient struct { cc grpc.ClientConnInterface } func NewHelloClient(cc grpc.ClientConnInterface) HelloClient { return \u0026helloClient{cc} } func (c *helloClient) GET(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloRes, error) { out := new(HelloRes) err := c.cc.Invoke(ctx, \"/admin.Hello/GET\", in, out, opts...) if err != nil { return nil, err } return out, nil } type HelloServer interface { GET(context.Context, *HelloReq) (*HelloRes, error) mustEmbedUnimplementedHelloServer() } // UnimplementedHelloServer must be embedded to have forward compatible implementations. type UnimplementedHelloServer struct { } func (UnimplementedHelloServer) GET(context.Context, *HelloReq) (*HelloRes, error) { return nil, status.Errorf(codes.Unimplemented, \"method GET not implemented\") } ","date":"2023-08-16","objectID":"/posts/golang/grpc/:3:3","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"proto语法 官网语法地址 https://developers.google.com/protocol-buffers/docs/proto3 语法演示 //--------------------------声明--------------------------------- syntax = \"proto3\"; // 向编译器声明语法版本 option go_package = \"./;admin\"; //admin表示包名；需求放在admin文件夹下，否则报错 package admin; //----------------------------结构体------------------------------ /* 多行注释 */ //------数据类型----- message User { string query = 1; // 字段值可传一个或者不传；编号用在二进制消息格式中区分字段 string Name =1; bool x10=10; double id=2; float x0=9; bytes x11=11; int32 x=3; int64 x2=5; uint32 x1=4; uint64 x3=6; sint32 x4=7; sint64 x5=8; } //-------数据结构----- message person{ repeated string ary =1; //数组 map\u003cstring,string\u003e map_S=3; //地图 enum SEX{ //枚举全部大写，必须0开始 MAN =0; WOMAN=1; OTHER =3; } SEX sex =3; } //----------嵌套类型------------ message Test{ map\u003cstring,user\u003e map_user=1; repeated user user_ary=2; message V{ string name =1; } V v=3； //使用嵌套结构体V;结构体与名称不能相同； } //------------- message save_key { reserved \"key1\",\"key2\"；//保留key值 reserved 4,5,6,7; //保留唯一标识 } //----------------------------服务端四种传输方式--------------------------- service Person{ rpc serch(personRequest) returns(personRely){} //即可响应 rpc serchin(stream personRequest) returns(personRely){} //入参为流 rpc serchout(personRequest) returns(stream personRely){} //出参为流 rpc serchio(stream personRequest) returns(stream personRely){} //双向流 } //----------------------------消息体------------------------------ message loginRequest{ } message loginReply{ } ","date":"2023-08-16","objectID":"/posts/golang/grpc/:3:4","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"三、grpc代码实现 ","date":"2023-08-16","objectID":"/posts/golang/grpc/:4:0","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"服务端代码实现 代码实现步骤 server端实现 - 实现步骤 1. 服务实现 2. 创建监听套接字 3. 创建服务端 4. 注册服务 5. 启动服务端 func main() { //2.创建套接字监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:8080\") if err != nil{ panic(err.Error()) } //3.创建服务端 server:=grpc.NewServer() //4.注册服务： person.RegisterPersonServer(server,admin.Admin{}) person.RegisterAdminServer(server,P.P{}) reflection.Register(server) //配合grpcUI使用 //5.启动服务端： err= server.Serve(listen) } 官方服务端实现实例 https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go ","date":"2023-08-16","objectID":"/posts/golang/grpc/:4:1","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"四、grpc-UI 官网 https://github.com/fullstorydev/grpcui ","date":"2023-08-16","objectID":"/posts/golang/grpc/:5:0","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"安装 go install github.com/fullstorydev/grpcui/cmd/grpcui@latest 下载成功后会在gopath的bin目录下生成grpcui的可执行程序 ","date":"2023-08-16","objectID":"/posts/golang/grpc/:5:1","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"基本命令 grpcui -help //表示安装成功 grpcui -plaintext localhost:12345 //启动grpc客户端进行grpc调用测试 ","date":"2023-08-16","objectID":"/posts/golang/grpc/:5:2","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["golang"],"content":"四种传输方式的请求 requsert form 即可响应 request Data 输入一个请求对象的参数 response 返回一个响应对象 入参为流 request Data 点击request data 中的add item按钮，添加多个对象，多个对象按一次请求发送（后端需要for接收recv对象，当出错时就传输完成了） response 返回一个响应对象 出参为流 request Data 输入一个请求对象的参数 response 返回多个对象（后端需要for来返回send对象，当一个对象返回结束后，给出一个提示继续返回下一个对象） 出入均为流 json 在处理具有流请求的 RPC 时，JSON 数据将是一个 JSON 数组，其中每个元素都是流中的一条消息。 ","date":"2023-08-16","objectID":"/posts/golang/grpc/:5:3","tags":["golang"],"title":"golang - grpc 开源框架","uri":"/posts/golang/grpc/"},{"categories":["http"],"content":"HTTP传输大文件的方法 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:1:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"分块传输 压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。 这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。 这种“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。 其实也很简单，同样采用了明文的方式，很类似响应头。 每个分块包含两个部分，长度头和数据块； 长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明文，用 16 进制数字表示长度； 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF； 最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:1:1","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"范围请求 比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。 HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。 范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。 如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。 请求头Range是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。 要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。 Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么： “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件； “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”； “-1”是文档的最后一个字节，相当于“99-99”； “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。 服务器收到 Range 字段后，需要做四件事。 第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码416，意思是“你的范围请求有误，我无法处理，请再检查一下”。 第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。 第三，服务器要添加一个响应头字段Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。 最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。 HTTP/1.1 206 Partial Content Content-Length: 32 Accept-Ranges: bytes Content-Range: bytes 0-31/96 // this is a plain text json doc ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:1:2","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"长连接 HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。 连接\r使用长连接机制，使用的字段是Connection，值是“keep-alive”。 不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:2:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"连接控制 长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。 在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接 服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式： 使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。 使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。 客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。 我们的实验环境配置了“keepalive_timeout 60”和“keepalive_requests 5”，意思是空闲连接最多 60 秒，最多发送 5 个请求。所以，如果连续刷新五次页面，就能看到响应头里的“Connection: close”了。 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:2:1","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"队头阻塞 “队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。 因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。 如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。 队头阻塞\r","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:2:2","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"缓存控制 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:3:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"服务器缓存 整个流程翻译成 HTTP 就是： 浏览器发现缓存无数据，于是发送请求，向服务器获取资源； 服务器响应请求，返回资源，同时标记资源的有效期； 浏览器缓存资源，等待下次重用。 服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。” 还有其他的方式来控制资源的有效期： no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面； no_cache：它的字面含义容易与 no_store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本； must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。 缓存控制流程\r服务器可以根据请求资源的性质来告诉客户端是否需要对资源进行缓存 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:3:1","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"代理服务器 其实 HTTP 协议中它就是在客户端和服务器原本的通信链路中插入的一个中间环节，也是一台服务器，但提供的是“代理服务” 所谓的“代理服务”就是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。 代理最基本的一个功能是负载均衡。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求。 代理服务器\r在负载均衡的同时，代理服务还可以执行更多的功能，比如： 健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用； 安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载； 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本； 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应； 内容缓存：暂存、复用服务器响应 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:4:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"代理相关头字段 代理的好处很多，但因为它“欺上瞒下”的特点，隐藏了真实客户端和服务器，如果双方想要获得这些“丢失”的原始信息，该怎么办呢？ 首先，代理服务器需要用字段“Via”标明代理的身份。 Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。 如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。 例如下图中有两个代理：proxy1 和 proxy2，客户端发送请求会经过这两个代理，依次添加就是“Via: proxy1, proxy2”，等到服务器返回响应报文的时候就要反过来走，头字段就是“Via: proxy2, proxy1 代理链路\r","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:4:1","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"缓存代理 但 HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果。特别是对于那些“读多写少”的数据 HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等） 反向代理\r代理服务收到源服务器发来的响应数据后需要做两件事。第一个当然是把报文转发给客户端，而第二个就是把报文存入自己的 Cache 里。 下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:5:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"总结 总结： 传输大文件的方式可以使用：分块传输和范围请求；两种方式必须建立在长连接的基础上 ​ 分块传输可以降低宽带的占用和传输时间，通过字段Transfer-Encoding: chunked来表示报文的连续性； ​ 范围请求使用Content-Range字段来表示报文的连续性 使用长连接过程中可能会出现一些问题，导致连接无法断开；这是需要有一个控制连接断开的参数，可通过keepalive_timeout”和“keepalive_requests\"字段来限制最长的连接时间或者最多的请求次数 队头阻塞是长连接传输数据过程中出现阻塞，导致后续请求全部阻塞的问题，http/1.1中暂时无法解决该问题 ","date":"2023-08-16","objectID":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/:6:0","tags":["http"],"title":"http - 《三》 进阶篇","uri":"/posts/http/%E4%B8%89%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E8%BF%9B%E9%98%B6%E7%AF%87/"},{"categories":["http"],"content":"HTTP报文是什么样子的？ ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:0","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"报文结构 HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成： 起始行（start line）：描述请求或响应的基本信息：叫做请求行和状态行 头部字段集合（header）：使用 key-value 形式更详细地说明报文：叫做请求头和响应头 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据：叫做请求体和响应体 这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。 HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。 所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。 报文结构\r实际报文\r","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:1","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"请求行 请求行由三部分构成： 请求方法：是一个动词，如 GET/POST，表示对资源的操作； 请求目标：通常是一个 URI，标记了请求方法要操作的资源； 版本号：表示报文使用的 HTTP 协议版本。 这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。 请求行\r实际请求头： GET /index HTTP/1.1 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:2","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"请求头/响应头 请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头 的示意图 头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束 HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。 请求头\r请求行\r不过使用头字段需要注意下面几点： 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好； 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名； 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格； 字段的顺序是没有意义的，可以任意排列不影响语义； 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。 HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类： 通用字段：在请求头和响应头里都可以出现； 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件； 响应字段：仅能出现在响应头里，补充说明响应报文的信息； 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:3","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"请求体 在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。 所谓的超文本就是可以传输各种数据，体现在body中，但是双方必须要在头部字段中说明，本次传输的数据类型 这里简单列举一下在 HTTP 里经常遇到的几个类别： text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。 image：即图像文件，有 image/gif、image/jpeg、image/png 等。 audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。 application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。 Encoding type 字段 告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。 Encoding type 就少了很多，常用的只有下面三种： gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式； deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip； br：一种专门为 HTTP 优化的新压缩算法（Brotli）。 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:4","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"状态行 我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。 同样也是由三部分构成： 版本号：表示报文使用的 HTTP 协议版本； 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误； 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因 状态行\r实际状态头： HTTP/1.1 200 OK HTTP/1.1 404 Not Found ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:5","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"常用头部字段 Host字段 它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。 当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择 User-Agent字段 只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。 Date字段 属于通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。 Content-Length 字段 表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输 Accept字段 客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地， Accept: text/html,application/xml,image/webp,image/png 这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据 Accept: text/html,application/xml;q=0.9,*/*;q=0.8 它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。 Content-Type 字段 服务器会在响应报文里用头字段Content-Type告诉客户端实体数据的真实类型 Content-Type: text/html; charset=utf-8 Content-Type: image/png 浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，utf-8表示实体数据的字符编码；看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。 Accept-Encoding 字段 表示 客户端支持的压缩格式 同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段Content-Encoding里。 Accept-Encoding: gzip, deflate, br Content-Encoding: gzip 不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。 Accept-Language 子弹 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如： Accept-Language: zh-CN, zh, en 这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文” ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:6","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"请求方法介绍 目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，我先简单地列把它们列出来，后面再详细讲解。 GET：获取资源，可以理解为读取或者下载数据； HEAD：获取资源的元信息； POST：向资源提交数据，相当于写入或上传数据； PUT：类似 POST； DELETE：删除资源； CONNECT：建立特殊的连接隧道； OPTIONS：列出可对资源实行的方法； TRACE：追踪请求 - 响应的传输路径。 http请求方法\r","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:0","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"GET/HEAD GET 应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。 它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。 GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。 例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。 HEAD HEAD方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。 HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费 比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:1","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"POST/PUT 向 URI 指定的资源提交数据，数据就放在报文的 body 里。 比如，你上论坛灌水，敲了一堆字后点击“发帖”按钮，浏览器就执行了一次 POST 请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP 协议发给服务器。 PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”或者\"insert\"的含义，而 PUT 则是“修改”“update”的含义。 在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。 在发送请求时，POST/PUT方法一般携带头字段“Content-Length”表示body的长度 POST /10-2 HTTP/1.1 Host: www.chrono.com Content-Length: 17 POST DATA IS HERE PUT /10-2 HTTP/1.1 Host: www.chrono.com Content-Length: 16 PUT DATA IS HE ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:2","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"其他方法 讲完了 GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较“冷僻”的方法，应用的不是很多。 DELETE方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。 CONNECT是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。 OPTIONS方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。 TRACE方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:3","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"安全与幂等 关于请求方法还有两个面试时有可能会问到、比较重要的概念：安全与幂等。 在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。 按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。 而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。 所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。 POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。 我对你的建议是，你可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。 数据安全与幂等问题关键在于使用的sql和业务逻辑，一般来说create 和 insert 语句会存在问题，当然也有 其他方式可以解决安全与幂等问题 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:3:0","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"URI的组成 在电脑术语中，统一资源标识符（Uniform Resource Identifier，URI)是一个用于标识某一互联网资源名称的字符串 Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用资源标识符（Uniform Resource Identifier, 简称\"URI\"）进行定位。 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。 uri组成\rURI 第一个组成部分叫scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。 在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。 在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。 有了协议名和主机地址、端口号，再加上后面标记资源所在位置的path，浏览器就可以连接服务器访问资源了。 实际uri： http://www.chrono.com:8080/11-1?uid=1234\u0026name=mario\u0026referer=xxx ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:4:0","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"状态码的使用 这五类的具体含义是： 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作； 2××：成功，报文已经收到并被正确处理； 3××：重定向，资源位置发生变动，需要客户端重新发送请求； 4××：客户端错误，请求报文有误，服务器无法处理； 5××：服务器错误，服务器在处理请求时内部发生了错误。 目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:5:0","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"常见状态码 1×× “101 Switching Protocols” 它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。 2xx “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据 “204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。 “206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。 状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围 例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。 但表示 body 只是原数据的一部分。 多用于大文件范围请求传输 3xx 301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。 “302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。 “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。 301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制” 4xx “400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。 “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。 “404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。 4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有： 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET； 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文； 408 Request Timeout：请求超时，服务器等待了过长的时间； 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态； 413 Request Entity Too Large：请求报文里的 body 太大； 414 Request-URI Too Long：请求行里的 URI 太大； 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略； 431 Request Header Fields Too Large：请求头某个字段或总体太大； 5xx 5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。 “500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。 “501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。 “502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。 “503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。 503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。 ","date":"2023-08-16","objectID":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/:5:1","tags":["http"],"title":"http - 《二》 基础篇","uri":"/posts/http/%E4%BA%8C%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["http"],"content":"什么是安全？ 通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。 机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。 比如小明和小红私下聊天，但“隔墙有耳”，被小强在旁边的房间里全偷听到了，这就是没有机密性。我们之前一直用的 Wireshark ，实际上也是利用了 HTTP 的这个特点，捕获了传输过程中的所有数据。 完整性（Integrity，也叫一致性）是指数据在传输过程中没有被窜改，不多也不少，“完完整整”地保持着原状。 机密性虽然可以让数据成为“秘密”，但不能防止黑客对数据的修改，黑客可以替换数据，调整数据的顺序，或者增加、删除部分数据，破坏通信过程。 比如，小明给小红写了张纸条：“明天公园见”。小强把“公园”划掉，模仿小明的笔迹把这句话改成了“明天广场见”。小红收到后无法验证完整性，信以为真，第二天的约会就告吹了。 身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。 如果通信时另一方是假冒的网站，那么数据再保密也没有用，黑客完全可以使用冒充的身份“套”出各种信息，加密和没加密一样。 比如，小明给小红写了封情书：“我喜欢你”，但不留心发给了小强。小强将错就错，假冒小红回复了一个“白日做梦”，小明不知道这其实是小强的话，误以为是小红的，后果可想而知。 第四个特性是不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。 比如，小明借了小红一千元，没写借条，第二天矢口否认，小红也确实拿不出借钱的证据，只能认倒霉。另一种情况是小明借钱后还了小红，但没写收条，小红于是不承认小明还钱的事，说根本没还，要小明再掏出一千元。 所以，只有同时具备了机密性、完整性、身份认证、不可否认这四个特性，通信双方的利益才能有保障，才能算得上是真正的安全 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:1:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"https HTTPS 其实是一个“非常简单”的协议，RFC 文档很小，只有短短的 7 页，里面规定了新的协议名“https”，默认端口号 443，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。 也就是说，除了协议名“http”和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。 既然没有新东西，HTTPS 凭什么就能做到机密性、完整性这些安全特性呢？ 秘密就在于 HTTPS 名字里的“S”，它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上（可参考第 4 讲和第 5 讲），收发报文不再使用 Socket API，而是调用专门的安全接口。 tls\r","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:2:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"SSL/TLS SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。 SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。 TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。 浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。 使用的 TLS 是 1.2，客户端和服务器都支持非常多的密码套件，而最后协商选定的是“ECDHE-RSA-AES256-GCM-SHA384”。 其实 TLS 的密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”，比如刚才的密码套件的意思就是： “握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。” ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:3:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"OpenSSL 说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。 OpenSSL 是从另一个开源库 SSLeay 发展出来的，曾经考虑命名为“OpenTLS”，但当时（1998 年）TLS 还未正式确立，而 SSL 早已广为人知，所以最终使用了“OpenSSL”的名字。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:4:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"加密算法 实现机密性最常用的手段是“加密”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。 这里的“钥匙”就叫做“密钥”（key），加密前的消息叫“明文”（plain text/clear text），加密后的乱码叫“密文”（cipher text），使用密钥还原明文的过程叫“解密”（decrypt），是加密的反操作，加密解密的操作过程就是“加密算法”。 由于 HTTPS、TLS 都运行在计算机上，所以“密钥”就是一长串的数字，但约定俗成的度量单位是“位”（bit），而不是“字节”（byte）。比如，说密钥长度是 128，就是 16 字节的二进制串，密钥长度 1024，就是 128 字节的二进制串。 按照密钥的使用方式，加密可以分为两大类：对称加密和非对称加密。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:5:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"对称加密 “对称加密”很好理解，就是指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。 TLS 里有非常多的对称加密算法可供选 目前常用的只有 AES 和 ChaCha20。 AES AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法。 ChaCha20 ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。 加密分组模式 对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文 最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。 把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。 比如，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM；ChaCha20-Poly1305 的意思是 ChaCha20 算法，使用的分组模式是 Poly1305。 你可以用实验环境的 URI“/24-1”来测试 OpenSSL 里的 AES128-CBC，在 URI 后用参数“key”“plain”输入密钥和明文，服务器会在响应报文里输出加密解密的结果。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:6:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"非对称加密 对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“密钥交换” 它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。 公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。 在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。 RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。 10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024 已经不安全，普遍认为至少要 2048 位。 比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了 公钥\r","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:7:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"混合加密 RSA 的运算速度是非常慢的，2048 位的加解密大约是 15KB/S（微秒或毫秒级），而 AES128 则是 13MB/S（纳秒级），差了几百倍。 TLS 里使用的混合加密方式，其实说穿了也很简单： 在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。 然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。 混合加密\r黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。 在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:8:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"摘要算法 实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。 你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。 换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。 因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数（PRF，pseudo random function） 目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。 SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。 摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。 比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。 不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。 所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。 这有个术语，叫哈希消息认证码（HMAC）。 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1） 不够安全，在 TLS 里已经被禁止使用了。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:9:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"数字签名 实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function） 这个东西就是非对称加密里的“私钥”，使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。 数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。 但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。 签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是 数字签名\r刚才的这两个行为也有专用术语，叫做“签名”和“验签” ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:10:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"数字证书CA 这里还有一个“公钥的信任”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？ 这个“第三方”就是我们常说的CA（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。 CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。 知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。 DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。 证书链\r","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:11:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"TLS协议组成 TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。 记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。 警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。 握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。 最后一个是变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。 下面的这张图简要地描述了 TLS 的握手过程，其中每一个“框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。 tls握手\r","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:12:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"ECDHE 握手过程 TLS握手详解1\r在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。 Handshake Protocol: Client Hello Version: TLS 1.2 (0x0303) Random: 1cbf803321fd2623408dfe… Cipher Suites (17 suites) Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f) Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030) 作为“礼尚往来”，服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。 Handshake Protocol: Server Hello Version: TLS 1.2 (0x0303) Random: 0e6320f21bae50842e96… Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030) 接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。 Handshake Protocol: Server Key Exchange EC Diffie-Hellman Server Params Curve Type: named_curve (0x03) Named Curve: x25519 (0x001d) Pubkey: 3b39deaf00217894e... Signature Algorithm: rsa_pkcs1_sha512 (0x0601) Signature: 37141adac38ea4... 之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。” 这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。 TLS详解2\rTLS详解3\r客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。 Handshake Protocol: Client Key Exchange EC Diffie-Hellman Client Params Pubkey: 8c674d0e08dc27b5eaa… 现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。 现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会 话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:13:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"小结 HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接； 握手的目标是安全地交换对称密钥，需要三个随机数，第三个随机数“Pre-Master”必须加密传输，绝对不能让黑客破解； “Hello”消息交换随机数，“Key Exchange”消息交换“Pre-Master”； “Change Cipher Spec”之前传输的都是明文，之后都是对称密钥加密的密文。 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:13:1","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["http"],"content":"总结 网络传输提出了四个安全的概念：机密性、完整性，身份认证和不可否认。 https是http+ssl/tls的组成 TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了 对称加密、非对称加密、身份认证等许多密码学前沿技术。 加密算法是指用秘钥加密和解密的过程；主要方式为对称加密和非对称加密 对称加密：主要使用AES ，加密解密使用相同的秘钥，在tls中由三个随机数生成秘钥 非对称加密：主要使用RSA，有公钥私钥两把钥匙，公钥加密只能私钥解密，私钥加密只能公钥解密 混合加密：因为非对称加密的性能较差，在tls中 第一次时候非对称加密，之后都时候对称加密 数字签名：由非对称加密+摘要算法生成。将body数据进行摘要，再将摘要使用私钥加密，加密后的密文就叫数字签名 ","date":"2023-08-16","objectID":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/:14:0","tags":["http"],"title":"http - 《四》 安全篇","uri":"/posts/http/%E5%9B%9B%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%AE%89%E5%85%A8%E7%AF%87/"},{"categories":["database"],"content":"《一》mongoDB—初始与安装 ","date":"2023-08-16","objectID":"/posts/database/mongodb/:0:0","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1、什么是mongdb ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:0","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.1 介绍 MongoDB是一个文档数据库(以]SON 为数模型)，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案. 文档来白丁“SON Document”，并非我们一般理解的 PDF，WORD 文档 MongoDB是一个个于关系数据库和非关系数招库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，教据格式是BSON，一种类似SON的二进制形式的存储格式，简称BinaryJSON，和SON一样支持内的文对象和数组对象，因此可以存储比较复杂的数据类型，MongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言几乎可以实现举似关系数据库单表查询的绝大部分功能，而目还支持对数据建立索引。原则上 oracle 和 MVSOL 能做的事情MongoDB 都能做 (包括 ACID 事务) ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:1","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.2 版本 2018年08月06日，MongoDB 4.0.2发布，支持多文档事务。 2019年08月13日，MongoDB 4.2.0 发布 [3] ，引入分布式事务。 ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:2","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.3 设计特征 MongoDB 的设计目标是高性能、可扩展、易部署、易使用，存储数据非常方便。其主要功能特性如下。 （1）面向集合存储，容易存储对象类型的数据。在MongoDB 中数据被分组存储在集合中，集合类似RDBMS 中的表，一个集合中可以存储无限多的文档。 （2）模式自由，采用无模式结构存储。在MongoDB 中集合中存储的数据是无模式的文档，采用无模式存储数据是集合区别于RDBMS 中的表的一个重要特征。 （3）支持完全索引，可以在任意属性上建立索引，包含内部对象。MongoDB的索引和RDBMS 的索引基本一样，可以在指定属性、内部对象上创建索引以提高查询的速度。除此之外，MongoDB 还提供创建基于地理空间的索引的能力。 （4）支持查询。MongoDB 支持丰富的查询操作，MongoDB 几乎支持SQL中的大部分查询。 （5）强大的聚合工具。MongoDB 除了提供丰富的查询功能外，还提供强大的聚合工具，如count、group 等，支持使用MapReduce 完成复杂的聚合任务。 （6）支持复制和数据恢复。MongoDB 支持主从复制机制，可以实现数据备份、故障恢复、读扩展等功能。而基于副本集的复制机制提供了自动故障恢复的功能，确保了集群数据不会丢失。 （7）使用高效的二进制数据存储，包括大型对象（如视频）。使用二进制格式存储，可以保存任何类型的数据对象。 （8）自动处理分片，以支持云计算层次的扩展。MongoDB 支持集群自动切分数据，对数据进行分片可以使集群存储更多的数据，实现更大的负载，也能保证存储的负载均衡。 （9）支持Perl、PHP、Java、C#、JavaScript、Ruby、C 和C++语言的驱动程序，MongoDB 提供了当前所有主流开发语言的数据库驱动包，开发人员使用任何一种主流开发语言都可以轻松编程，实现访问MongoDB 数据库。 （10）文件存储格式为BSON（JSON 的一种扩展）。BSON 是对二进制格式的JSON 的简称，BSON 支持文档和数组的嵌套。 （11）可以通过网络访问。可以通过网络远程访问MongoDB 数据库。 ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:3","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.4 基本概念 sql概念 mongoDB概念 数据库(database) 数据库(database) 表(table) 集合(collection) 行(row) 文档(document) 列(column) 字段(feld) 索引(index) 索引(index) 主键(primary key) _id (字段) 视图(view) 视图 (view) 表连接 (table joins) 聚合操作(Slookup) ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:4","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.5 应用场景 从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域: 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、分等直接以内嵌文档的形式存储，方便查询、 更新;物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongoDB 内欧数组的形式来存储，一次查询就能将订单所有的变更读取出来; 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能. 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析: 视频直播，使用 MongoDB 存储用户信息、礼物信息等, ·大数据应用，使用云数据库MongoDB作为大数据的云存储系统，随时进行数据提取分析，掌握行业动态。 ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:5","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1.6 是否选择MongoDB? 没有某个业务场景必须要使用MongODB才能解决，但使用MongODB通常能让你以更低的成本解决问题，如果你不清楚当前业务是否适合使用MongoDB.可以通过做几道选择题来辅助决策。 应用不需要复杂/长事务及 join 支持 新应用，需求会变，数据模型无法确定，想快速迭代开发应用需要2000-3000以上的读写QPS 更高也可以) 应用需要TB甚至 PB 级别数据存储 应用发展迅速，需要能快速水平扩展 应用要求存储的数据不丢失 应用需要99.999%高可用 应用需要大量的地理位置查询、文本查询 ","date":"2023-08-16","objectID":"/posts/database/mongodb/:1:6","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"2、 宝塔搭建mongoDB ","date":"2023-08-16","objectID":"/posts/database/mongodb/:2:0","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"指定用户连接指定数据库 mongo --port 27017 -u \"root\" -p \"123456\" --authenticationDatabase=admin ","date":"2023-08-16","objectID":"/posts/database/mongodb/:2:1","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"3、docker 搭建mongoDB ","date":"2023-08-16","objectID":"/posts/database/mongodb/:3:0","tags":["mongoDB"],"title":"mongoDB - 基础介绍","uri":"/posts/database/mongodb/"},{"categories":["database"],"content":"1、 管理角色介绍 权限名 描述 read 允许用户读取指定数据库 readWrite 允许用户读写指定数据库 dbAdmin 允许用户在指定数据库中执行管理函数，如素引创建、删除，查看统计或访问system.profile dbowner 允许用户在指定数据库中执行任意操作，增、删、改、查等 userAdmin 许用户向systemm.users集合写入，可以在指定数据库里创建、删除和管理用户 clusterAdmin 只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限 readAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase 只在admin数据库中可用，赋了用户所有数据库的读写权限 userAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase 只在admin数据库中可用，予用户所有数据库的dbAdmin权限 root 只在admin数据库中可用。招级账号，招级权限 用户认证，返回1表示认证成功 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:1:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"2、角色操作 ## 创建角色，root用户必须切换到admin库使用 db.createUser({user:'name',pwd:'pd',roles:['root']}) ## 给指定turan数据库创建用户 use turan; db.createUser({user:'name',pwd:'pd',roles:['dbOwner']}) ## 指定用户连接指定数据库 mongo --port 27017 -u \"name\" -p \"pd\" --authenticationDatabase=turan ## 删除用户 db.system.users.remove({user:\"用户名\"}) ## 查看当前数据库已存在的用户列表 show users ## 查看当前数据库角色列表,可在创建用户时选择这些角色 show roles ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:2:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"3、 数据库操作 ## 查看所有数据库 show dbs ## 切换数据库，不存在时创建 use test ## 删除当前数据库，使用前先切换到指定数据库 db.dropDatabase() ## 查看当前数据库集合 show tables show collections ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:4:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"4、 集合操作 集合是一个环形链表，环形链表头尾是相连的，当尾部溢出时，会从头部开始覆盖数据；在创建集合时有三个可选参数 optionse参数： 参数 类型 描述 capped 布尔 (可选)如果为true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 size 数值 (可选)为固定集合指定一个最大值 (以字节计) 。如果 capped 为 true，也需要指定该字段 max 数值 (可选)指定固定集合中包含文档的最大数量 当集合不存在时，向集合中插入文档也会创建集合 ## 创建集合 ## 删除集合 ## 查看集合信息 db.集合名.stats(); ## 查看集合帮助信息 db.集合名.help(); ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:5:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"5、插入文档 必须先切换到指定的数据库，然后再指定集合使用查询api use turan // 使用turan数据库 ## 插入一条 db.document.insertOne({\"test\":'test'},{writeConcern:1,ordered:true} ) - writeConcern ：默认为1，1表示节点的数量，可选大于1;majority表示写操作被大多数节点写入成功才算成功 - ordered ： 按顺序写入，默认为true； ## 插入多条 db.document.insertMany([{\"test\":'test'},{\"test\":'test'}]) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:6:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"6、 查询文档 可以用find命令对指定的数据进行更新，命令的格式如下: db.document.find(query,projection) query: 可选，使用查询操作符指定查询条件 projection: 可选，查询列表 6.1 多文档查询 ## 空参数 db.document.find() 一次性最多返回20条，大于时使用it继续获取 ## 查询title为qwe的文档，只返回title字段 db.document.find({title:'qwe'},{title:1}) 条件和筛选字段查询 ## 使用id查询 db.document.find({_id:ObjectID(\"xxxxxxxxxx\")}) 需要将id值转成objectid ## 查询likenum数大于60的文档， db.document.find({likeNum:{$gt:60}}) 6.2 查询操作符 SQL MQL a=1 {a: 1} a\u003c\u003e1 {a: {$ne: 1}} a\u003e1 {a: {$gt: 1}} a\u003e=1 {a: {$gte: 1}} a\u003c1 {a: {$lt: 13}} a\u003c=1 {a: ($lte: 1}} a=1AND b=1 {a: 1, b: 1} a= 1 0R b= 1 {$or:[{a:1},{b:1}]} a Is NULL {a: {$exists: false}} a lN (1, 2, 3) {a: {$in: [1, 2, 3]}} 6.3 排序查询 ## 按likeNum字段降序 db.document.find(query,projection).sort({likeNum:-1}) ## 按likeNum字段升序 db.document.find(query,projection).sort({likeNum:1}) 6.4 分页查询 ## 跳过4行后，获取4行数据 db.document.find(query,projection).skip(4).limit(4).sort({likeNum:-1}) 6.5 模糊查询 ## 按tpye模糊匹配qwe db.document.find({type:/qwe/}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:7:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7、 更新文档 可以用update命令对指定的数据进行更新，命令的格式如下: ## 更新单条 db.collTection.updateOne(query,update,options) ## 更新多条 db.collTection.updateMany(query,update,options) query: 描述更新的查询条件: update: 描述更新的动作及新的内容: options: 描述更新的 选项 upsert: 可选，如果不存在update的记录，是否插入新的记录。默认false，不插入。 writeConcern :可选，决定一个写操作落到多少个节点上才算成功。 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7.1 更新操作符 操作符 格式 描述 $set ($set:{field:value}} 指定一个键并更新值，若键不存在则创建 $unset ($unset : {field : 1 }} 删除一个键 $inc {$inc : {field : value }} 对数值类型进行增减 $rename {$rename :{ fold field name : new field name }} 修改字段名称 $push {$push : {field : value }} 将数值追加到数组中，若数组不存在则会进行初始化 $pushAll {$pushAll : {field : value_array}} 追加多个值到一个数组字段内 $pull {$pull : {field :_value}} 从数组中删除指定的元素 $addToSet {$addToSet : {field ; value }} 添加元素到数组中，具有排重功能 $pop {$pop : {field : 1}} 删除数组的第一个或最后一个元素 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:1","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7.2 操作符使用 ## $set ：查询值为1,2,3的a字段，并将a更新为5 db.collTection.update({a:{$in:[1, 2, 3]}},{$set:{a:5}}) ## $unset ## $inc ## $rename ## $push ## $pushAll ## $pull ## $addToSet ## $pop ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:2","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7.3 upsert 属性 ## 如果title为1不存在，则插入一条title为2 db.collTection.updateOne({title:1},{$set:{title:2}},{upsert:true}) ## 如果title为1不存在，则放弃更新 db.collTection.updateOne({title:1},{$set:{title:2}}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:3","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7.4 replace 语义 ## 查询title等于1的文档的全部字段，完全替换为title等于2 db.collTection.updateOne({title:1},{title:2}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:4","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"7.5 findAndModify 命令 该语句只能更新单个文档： db.document.findAndModify( {query:{test:'test'},update:{$inc:{title:1}},new:true} ) query：需要查询的字段值 update：需要更新的字段值 new：默认为false，返回旧值文档；为true时，返回更新后的文档 ## 查询test字段等于test的文档，并将title+1，更新后返回更新后的文档 db.document.findAndModify( { query:{test:'test'}, update:{$inc:{title:1} }, new:true} ) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:8:5","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"8、删除文档 删除文档使用deleteMany和deleteOne操作； ## 删除多个文档 db.collection.deleteMany(query) ## 删除单个文档 db.collection.deleteOne(query) query: 查询列表 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:9:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"8.1 删除文档 ## 将title等于一的文档全部删除 db.collection.deleteMany({title:1}) ## 删除单个title等于1的文档 db.collection.deleteOne({title:1}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:9:1","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"8.2 返回被删除的文档 ## 删除一条test为test的文档，并返回该文档 db.document.findOneAndDelete({test:'test'}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:9:2","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"9 、聚合操作 聚合操作处理数招记录并返回计算结果(诸如统计平均值，求和等)。聚合操作组值来自多个文档，可以对分组数据执行各种操作以返回单个结果。案合操作包含三类: 单一作用聚合、聚合管道、MapReduce。 单一作用聚合: 提供了对常见聚合过程的简单访问，操作都从单个集合聚合文档。 聚合管道是一个数据聚合的框架，模型基于数据处理流水线的概念。文档进入多级管道，将文档转换为聚合结果。 MapReduce操作具有两个阶段:处理每个文档并向每个输入文档发射一个或多个对象的map阶段，以及reduce组合map操作的输出 阶段。 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:10:0","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"9.1 单一作用聚合 介绍 MongoDB提供 三种 这类单一作用的聚合函数，这些函数只能在一个集合中使用，所以在实战中使用较少； 函数 描述 db.collection.estimatedDocumentCount() 忽略查询条件，返回集合或视图中所有文档的计数 db.collection.count(query) 返回与find()集合或视图的查询匹配的文档计数 。等同于db.collection.find(query).count()构造 db.collection.distinct(query,filter) 在单个集合或视图中查找指定字段的不同值，并在数组中返回结果 使用 ## 返回document集合的总文档数量 db.document.estimatedDocumentCount() ## 返回title等于1的文档数量 db.document.count({title:1}) ## 只返回去重后的test字段值 db.collection.distinct(\"test\") ## 先查询likeNum小于13的文档，再去重title字段，单独返回title字段值 db.document.distinct(\"title\",{likeNum:{$lt: 13}}) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:10:1","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"9.2 聚合管道 介绍 MongoDB 聚合框架 (Aggregation Framework) 是一个计算框架，它可以: 作用在一个或几个集合上: 对集合中的数据进行的一系列运算 将这些数据转化为期望的形式 从效果而言，聚合框架相当于 SQL 查询中的GROUP BY、 LEFT OUTERJOIN 、AS等 整个聚合运算过程称为管道 (Pipeline) ，它是由多个阶段 (Stage) 组成的，每个管道: 接受一系列文档 (原始数据) 每个阶段对这些文档进行一系列运算结果将文档输出给下一个阶段; 在这个例子中 db.orders.aggregate([ { $match: { status: \"A\" } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$amount\" } } } ]) 第一阶段：$match阶段按status字段过滤文档，并将status等于\"A\"的文档传递到下一阶段。 第二阶段：$group阶段按cust_id字段将文档分组，以计算每个cust_id唯一值的金额总和。 语法 聚合管道操作语法 pipeline = [$stage1, $stage2, ...$stageN]; db.co1lection.aggregate(pipeline , {options}) pipelines 一组数据聚合阶段。除$out、$Merge和sgeonear阶段之外，每个阶段都可以在管道中出现多次。 options 可选，聚合操作的其他参数。包含: 查询计划、是否使用临时文件、游标、最大操作时间、读写策略、强制索引等等 使用 ## $project : 将title字段改为name；字段值为0时不展示，为1时展示该字段；有as和查询列表功能 db.document.aggregate([{$project:{name:\"$title\",_id:0,type:1}}]) ## $match和$count: 过滤test等于1223，然后统计过滤后的数量，并赋值返回到count字段 db.document.aggregate([{$match:{test:'1223'}},{$count:\"count\"}]) ## $group : 对test进行分组，然后对likeNum字段进行求和 db.document.aggregate([{$group:{_id:\"$test\",likenum:{$sum:\"$likeNum\"}}}]) ## $group : 对test进行分组，对title进行分组，然后对likeNum字段进行求和 db.document.aggregate([{$group:{_id:{test:\"$test\",title:\"$title\"},likenum:{$sum:\"$likeNum\"}}}]) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:10:2","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"9.3 聚合操作符 阶段 描述 SQL等价运算符 $match 筛选条件 where $project 投影 as $lookup 左外连接 left outer join $sort 排序 order by $group 分组 group by $skip/$limit 分页 $unwind 展开数组 $graphLookup 图搜索 $facet/$bucket 分面搜索 $group $group不会输出具体的文档而只是统计信息。 { $group:{ _id: \u003cexpression\u003e, \u003cfield1\u003e: { \u003caccumulatorl\u003e : \u003cexpression1\u003e }, ... } } _id宇家是必道的但是，可以指d值为null来为整个输入文档计算累计值 剩余的计算字段是可选的，并使用运算符进行计算。 _id和表达式可以接受任何有效的表达式. $unwind 可以将数组拆分为单独的文档 {$unwind: path: \u003cfield path\u003e， 37 incTudeArrayIndex: \u003cstring\u003e, preserveNu17AndEmptyArrays : \u003cboolean\u003e path:#妻指定字段路径，在字段名称前加上S符并用引号括起来。 incTudeArrayIndex:#可选，一个新宁段的名称用于存放元素的数组索引。该名称不能以S开头。 preserveNu17AndEmptyArrays:#可选，default ;false，若为true,如果路径为空，缺少或为空数组，则sunwind输出文档 ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:10:3","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"9.4 分组操作符 名称 描述 $avg 计算均值 $first 返回每组第一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的第一个文档。 $last 返回每组最后一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的最后个文档。 $max 根据分组，获取集合中所有文档对应值得最大值。 $min 根据分组，获取集合中所有文档对应值得最小值。 $push 将指定的表达式的值添加到一个数组中。 $addToSet 将表达式的值添加到一个集合中 (无重复值，无序)。 $sum 计算总和 $stdDevPop 返回输入值的总体标准偏差 (population standard deviation) $stdDevSamp 返回输入值的样本标准偏差 (the sample standard deviation) ","date":"2023-08-16","objectID":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/:10:4","tags":["mongoDB"],"title":"mongoDB -《二》 基础命令篇","uri":"/posts/database/%E4%BA%8Cmongodb---%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%AF%87/"},{"categories":["database"],"content":"mysql 索引全攻略 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:0:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"目录 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:1:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"目录结构 . ├── 分类\u0026特点 ├── 存储结构 ├── 查找过程 ├── 索引设计 ├── 索引失效 ├── 查询优化 ├── 覆盖索引 ├── 索引下推 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:1:1","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"分类\u0026特点 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:2:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"分类 MySQL的索引包括**普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引**等。。 从 功能逻辑 上说，索引主要有 4 种，分别是:普通索引、唯一索引、主键索引、全文索引。 按照 物理实现方式，索引可以分为 2 种: 聚簇索引和非聚簇索引。 I 按照 作用字段个数 进行划分成：单列索引和联合索引。 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:2:1","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"特点 普通索引 在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 任何数据类型 中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。 唯一性索引 使用UNIQUE参数 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里 可以有多个 唯一索引。 主键索引 主键索引就是一种 特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里 最多只有一个 主键索引。 全文索引 全文索引是前 搜索引擎 使用的一种关键技术。它能够用[分词技术]等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。 单列索引 联合索引 聚簇索引 非聚簇索引 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:2:2","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"存储结构 B+树： 聚簇索引： 非聚簇索引： ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:3:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"索引执行过程 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:4:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":" 联合索引为例： ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:4:1","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"索引设计 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:5:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":" 1.值为唯一的字段；例：手机号字段 2.频繁使用where查询的字段；例：用户名 3.需使用group by 和order by的字段,或两者一起用时，可以建立一个联合索引； 4.update、delete语句需要的where字段 5.需要DISTINCT返回的字段；排序后去重效果更快； 6.多表join连接操作时； 1.ON 的两个字段都建立索引 2.where 的字段建立索引 7.使用列的类型小的创建索引； 比如需要存一个ID字段数值为整数，那么可选数据类型有tinyint,int,bigint三种，tinyint类型比后两者更适合建立索引，所需类型空间小，在叶子节点中类型越小，存储的索引越多从而更快 8.使用字符串前缀创建索引 1.该项多用于长文本Varchar类型，比如：当varchar长度为100时，我们可以创建前缀索引，前缀索引的长度可以根据一个公式计算出来最合适的长度； 2.当该值越接近1时，代表该索引长度越适合，一般长度33%，认为是较好的索引 select count(distinct left(列名,索引长度)) / count(*) form [表名] 3.如果使用前缀索引字段进行排序，可能导致顺序并不正确，因为前缀索引不能决定整个字段值的顺序 9.将最频繁的列放到联合索引的左侧； 创建联合索引时，将最多用的字段放到第一个位置，其次是第二个位置，最不常用的越放后面 10.联合索引优于单值索引 创建联合索引时，最好将需要范围取值的字段放在最后； 11.索引建立字段最好加not null约束；或者将null替换为0或者空字符串 因为在查询时，使用is not null，会导致索引失效 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:5:1","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"索引失效 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:6:0","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":" 联合索引失效:建立联合索引顺序为(a,b,c) 在使用时 where a = ? and c = ? ，该语句只用上了a索引，c不会使用索引 在使用时 where b= ? and c = ? ，这个语句不会使用上索引,没有开始的a索引 在使用where a =? and b \u003c ? and c =?, 该语句a和b会使用索引,c不会使用索引 在使用where a =? and b = ? and c \u003c= ?, 该语句全部会使用索引 总结： 1， 使用联合索引时，必须要照索引建立的顺序来使用 2， 联合索引使用时，key_len越长速度越快 3. 范围条件右边的索引失效：\u003c \u003c= \u003e \u003e= 和between 索引字段进行了计算、函数、类型转换导致索引失效 select name from teacher where Left(name,1) = ?； //索引字段不能做运算， mysql不知道值是多少，会将每个索引值进行计算后，在进行对比，这样就导致全表扫描了 LIke以%开头的语句导致索引失效 页面搜索严谨左模糊或者全模糊，如有需要走搜索引擎来解决 select * from teacher where name like ‘%a’; //此处导致索引失败 OR语句前后存在非索引字段，导致索引失效 select * from teacher where name = ? or c_id =?; //查找name时，会使用索引，查找c_id时，需要全表扫描 查询使用不等于时，导致索引失效 where a != ？;那么a字段不会使用索引 is null 可以使用索引；is not null导致索引失效 where a is not null,这个相当于!= null where a is null, 这个相当于 = null; 使用or查询时，存在非索引列，导致索引失效 a是索引,b不是。where a = ? or b = ?,该语句是先查a，然后再查b，b不是索引，所以进行全表扫描； a和b都是单列索引， where a = ? or b = ? ;该语句可以用上索引 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:6:1","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"查询优化 连接查询 连接查询类似与嵌套循环，外层是主表数据，内层是副表数据，将主表的每一条数据与副表的全部数据进行对比连接； 保证被驱动表的JOIN字段已经创建了索引 需要JOIN 的字段，数据类型保持绝对一致。 。LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表 。减少外层循环的次数 。INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表。选择相信MySQL优化策略。能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) 主表（驱动表）根据where中涉及到的列建索引 从表根据被关联的列建立索引，如果where中涉及到从表的列，可以考虑结合关联列建立组合索引 子查询 语句分析 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再 撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引，所以查询性能会受到一定的影响。 对于返回结果集比较大的子查询，其对查询性能的影响也就越大 总结 不建议使用子查询，建议将子查询SOL拆开结合程序次查询，或使用JOIN 来代替子查询 排序查询 可以在WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，在ORDER BY 子句避免使用 FieSort 排序。当然，某些情况下全表扫描，或者 FileSot 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。 尽量使用index 完成ORDER BY排序。 如果WHERE和ORDER BY后面是相同的列就使用单索引列;如果不同2就使用联合索引。 无法使用Index 时，需要对 FileSort 方式进行调优。 分组查询 group by 使用索引的原则几乎跟order by一致，group by 即使没有过滤条件用到索引，也可以直接使用索引 group by 先排序再分组，遵照索引建的最佳左前缀法则 当无法使用索引列，增大max_length_for_sort_data和 sort_buffer_size 参数的设置 where效率高于having，能写在where限定的条件就不要写在having中了 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否 则SQL会很慢。 分页查询 语句分析 EXPLAIN SELECT * FROM student LIMIT 2000000,10; 一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 imit 2000000,10此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 该查询比较极端，分页查询一般与条件查询配合使用 优化思路 在索引完成排序分页操作后，再根据主键关联回原表查询所需要的其他列内容 该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 EXPLAIN SELECT * FROM student WHERE id \u003e 2000000 LIMIT 10; ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:6:2","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"覆盖索引 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:6:3","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["database"],"content":"索引下推 ","date":"2023-08-16","objectID":"/posts/database/mysqlindex/:6:4","tags":["mysql"],"title":"mysql - 索引全攻略","uri":"/posts/database/mysqlindex/"},{"categories":["css3"],"content":"样式引入 外部文件引入 \u003clink rel=\"stylesheet\" href=\"t.css\"\u003e link标签不需要放在style内部 ","date":"2023-08-03","objectID":"/posts/css/css3/:0:1","tags":["css3"],"title":"css3","uri":"/posts/css/css3/"},{"categories":["css3"],"content":"样式选择器 标签选择器 类型选择器 ID选择器 通配符选择器 Note\r一个标签可以选择多个样式,但是需要空格隔开 \u003cstyle\u003e .ul-l { color: red; } .ul-l2 { font-size: larger; } \u003c/style\u003e \u003cul class=\"ul-l ul-l2\"\u003e \u003cli\u003el1\u003c/li\u003e \u003cli\u003el2\u003c/li\u003e \u003cli\u003el3\u003c/li\u003e \u003c/ul\u003e ","date":"2023-08-03","objectID":"/posts/css/css3/:0:2","tags":["css3"],"title":"css3","uri":"/posts/css/css3/"},{"categories":["http"],"content":"HTTP是什么？ HTTP 就是超文本传输协议，也就是HyperText Transfer Protocol。 “超文本传输协议”，它可以拆成三个部分，分别是：“超文本”“传输”和“协议”。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。 http\r","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:1:0","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"协议 第一点，协议必须要有两个或多个参与者，也就是“协”。 例如，为了保证你顺利就业，“三方协议”里的参与者有三个：你、公司和学校；为了保证你顺利入住，“租房协议”里的参与者有两个：你和房东。 第二点，协议是对参与者的一种行为约定和规范，也就是“议”。 协议意味着有多个参与者为了达成某个共同的目的而站在了一起，除了要无疑义地沟通交流之外，还必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等 在计算机中通常指共同的一个约定：协议包括语法、语意和时序 ​ 语法： ​ 语意： ​ 时序： ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:1:1","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"传输 HTTP 是一个“传输协议”，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A\u003c===\u003eB” 第一点，HTTP 协议是一个“双向协议” 有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把 先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方 举例： 浏览器就是请求方 A，网易、新浪这些网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把一 些数据发送给网站，网站再把一些数据发回给浏览器，最后展现在屏幕上，你就可以看到各种有意思的新 闻、视频了 第二点，数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。 这样，传输方式就从“A\u003c===\u003eB”，变成了“A\u003c=\u003eX\u003c=\u003eY\u003c=\u003eZ\u003c=\u003eB”，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。 传输功能由tcp/ip完成，http是基于tcp/ip之上 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:1:2","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"超文本 超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 超文本指body中传输的数据可支持文字、图片、音频和视频等的混合 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:1:3","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"http相关应用 http扩展\r","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:1:4","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"http 相关协议 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:2:0","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"tcp/ip协议 这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层” TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 “可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节 IP 协议**是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:2:1","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"HTTPS HTTPS 相当于“HTTP+SSL/TLS+TCP/IP” SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。 SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:2:2","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"代理 代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。 代理有很多的种类，常见的有： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求； CDN实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。 关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订，但并不是 RFC 标准 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:2:3","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"域名的“新玩法” 有了域名，又有了可以稳定工作的解析系统，于是我们就可以实现比 IP 地址更多的“新玩法”了。 第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。 比如，你有一台“buy.tv”的服务器要临时停机维护，那你就可以通知 DNS 服务器：“我这个 buy.tv 域名的地址变了啊，原先是 1.2.3.4，现在是 5.6.7.8，麻烦你改一下。”DNS 于是就修改内部的 IP 地址映射关系，之后再有访问 buy.tv 的请求就不走 1.2.3.4 这台主机，改由 5.6.7.8 来处理，这样就可以保证业务服务不中断。 第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。 第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。 这种“玩法”也有两种方式，两种方式可以混用。 第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。 第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。 前面我们说的都是可信的 DNS，如果有一些不怀好意的 DNS，那么它也可以在域名这方面“做手脚”，弄一些比较“恶意”的“玩法”，举两个例子： “域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站； “域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。 好在互联网上还是好人多，而且 DNS 又是互联网的基础设施，这些“恶意 DNS”并不多见，你上网的时候不需要太过担心 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:3:0","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["http"],"content":"键入网址再按下回车，后面究竟发生了什么？ 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号； 浏览器用 TCP 的三次握手与服务器建立连接； 浏览器向服务器发送拼好的报文； 服务器收到报文后处理请求，同样拼好报文再发给浏览器； 浏览器解析报文，渲染输出页面。 请求过程\r但是在真实的网络系统中实际上更加复杂 1. 浏览器从地址栏的输入域名会先去域名服务器获取服务器的 IP 地址和端口号，返回后浏览器本地保存域名映射关系，供下一次直接访问； 2. 访问 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求 3. cdn没有再转发到 负载均衡设备 ， 负载均衡设备会先访问系统里的缓存服务器 4. 如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了 5. 最后网站的响应数据回到了你的设备 ","date":"2023-08-03","objectID":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/:4:0","tags":["http"],"title":"http - 《一》 初始篇","uri":"/posts/http/%E4%B8%80%E9%80%8F%E6%9E%90http%E5%8D%8F%E8%AE%AE--%E5%88%9D%E8%AF%86%E7%AF%87/"},{"categories":["javascript"],"content":"什么是window对象? window 是 JS 的最顶层对象 又叫 BOM 浏览器对象，window 包含了 主要的document,location,navigator,screen,history对象和自己的一些方法； ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:1:0","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"window 的常用方法 因为window对象是js中的顶级对象，因此所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法，在调用的时候可以省略window。 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:2:0","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"字符串类 用于对字符串进行转义、解析或执行。 encodeURI() decodeURI() 函数是用来对整个URL进行编码和解码的，它们会保留URL中的特殊字符，如冒号、斜杠、问号等。 const url = \"http://www.example.com?name=张三\u0026age=20\"; console.log(encodeURI(url)); // http://www.example.com?name=%E5%BC%A0%E4%B8%89\u0026age=20 console.log(decodeURI(\"http://www.example.com?name=%E5%BC%A0%E4%B8%89\u0026age=20\")); // http://www.example.com?name=张三\u0026age=20 String() 对一个非字符串类型的值进行文本操作时，可以用String() 来将其转换为字符串类型。入参可以是任何类型的值，会根据一定的规则将其转换为字符串类型。反参是一个字符串类型的值，如果入参是一个对象，那么反参就是该对象的字符串表示 // 数字类型的值 String(37); // \"37\" // 字符串类型的值 String(\"37\"); // \"37\" String(\"37.37\"); // \"37.37\" String(\"37,5\"); // \"37,5\" String(\"123ABC\"); // \"123ABC\" // 其他类型的值 String(true); // \"true\" String(false); // \"false\" String(null); // \"null\" String(undefined); // \"undefined\" Tip\rString() 方法是通过原型对象的 toString() 转换的，但不一定总是调用 toString() 。有些对象可能重写了 toString() 或 valueOf() 方法，或者定义了自己的 @@toPrimitive 方法，来改变转换的逻辑。\r","date":"2023-08-03","objectID":"/posts/javascript/js_window/:2:1","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"数值类型 isNaN() 在将任意值转换为数值类型时，判断该值是否为NaN;如果入参是NaN或者无法转换为数字，那么反参就是true，否则就是false console.log(isNaN(37)) // false isNaN(0 / 0); // true isNaN(\"37\"); // false isNaN(\"37.37\"); // false isNaN(\"37,5\"); // true isNaN(\"123ABC\"); // true isNaN(true); // false isNaN(false); // false isNaN(null) // false isNaN(undefined); // true isNaN({}); // true isNaN(new Date()); // false Number() Number() 的入参可以是任何类型的值，它会根据一定的规则将其转换为数字类型。反参是一个数字类型的值，如果入参无法转换为数字类型，那么反参就是NaN Number(37); // 37 // 字符串类型的值 Number(\"37\"); // 37 Number(\"37.37\"); // 37.37 Number(\"37,5\"); // NaN Number(\"123ABC\"); // NaN // 其他类型的值 Number(true); // 1 Number(false); // 0 Number(null); // 0 Number(undefined); // NaN Number({}); // NaN Number(new Date()); // 时间戳（毫秒数） parseFloat() 用来把一个字符串转换成一个浮点数的，它只接受十进制的字符串。它会忽略字符串前面的空白字符，然后从第一个非空白字符开始解析，直到遇到一个不能被解析为数字的字符为止。如果字符串的第一个非空白字符不能被解析为数字，或者字符串为空，那么它会返回NaN console.log(parseFloat(\"10\")); // 10 console.log(parseFloat(\"10.5\")); // 10.5 console.log(parseFloat(\"abc\")); // NaN console.log(parseFloat(\" 10.5\")); // 10.5 console.log(parseFloat(\"10.5abc\")); // 10.5 parseInt() 用来把一个字符串转换成一个整数的，它可以接受一个基数参数来指定字符串的进制。异常规则同上； console.log(parseInt(\"1011\", 2)); // 11 console.log(parseInt(\"B\", 16)); // 11 console.log(parseInt(\"10.5\")); // 10 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:2:2","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"定时器函数 用于设置延时或周期性执行的回调函数。 setTimeout() 此定时器只会执行一次并接收三个参数: handler: 需要执行函数; timeout： 延迟执行的时间; ...arguments： 执行函数的入参,执行函数没有入参时，可以不传; 该函数会返回定时器的唯一标识符，可以通过该标识符对定时器进行取消或修改 // 执行函数 function sayHello(msg, age) { console.log(msg, age); } const msg = \"Hello World\" // 设置定时器，延时一秒后执行； var timer = setTimeout(sayHello, 1000, msg, 1); // Hello World 1 clearTimeout() 专门用于清除通过setTimeout()生成的定时器，只需将定时器标识符传入即可；调用clearTimeout()后，定时器则自己销毁，不会再执行函数; // 执行函数 function sayHello(msg, age) { console.log(msg, age); } const msg = \"Hello World\" // 设置定时器，延时一秒后执行； var timer = setTimeout(sayHello, 1000, msg, 1); // 如果想要取消定时器，可以调用 clearTimeout 函数，并传入定时器的标识符 clearTimeout(timer); setInterval() 此定时器为周期性定时器函数，延时执行周期相同：如果不清理该定时器，则会永远按周期执行下去；入参和返参与setTimeout()相同 const msg = \"Hello World\" // 定义一个函数，打印出 Hello World function sayHello(msg, age) { console.log(msg, age); } // 设置定时器，延时一秒后循环执行； var timer = setInterval(sayHello, 1000, msg, 1); // Hello World 1 // Hello World 1 // Hello World 1 // ... Tip\r如果想要循环执行定时器，但是每个周期不同，可以参数以下操作； const msg = \"Hello World\" // 定义一个函数，打印出 Hello World function sayHello(msg, age) { console.log(msg); console.log(age) } for (let i = 0; i \u003c 10; i++) { // 每次循环创建一个定时器，按照不同的延时执行； var timer = setTimeout(sayHello, i * 1000, msg, 1); console.log(timer) } 注意！这样做会创建多个定时器 clearInterval() 专门用于清除通过setInterval()生成的定时器，只需将定时器标识符传入即可；调用clearInterval()后，定时器则自己销毁，不会再执行函数; // 定义一个函数，打印出当前时间 function showTime() { console.log(new Date().toLocaleString()); } // 设置一个重复执行的定时器，每隔1秒执行 showTime 函数 var timer = setInterval(showTime, 1000); // 在重复执行之前，调用 clearInterval 函数，并传入定时器的标识符 clearInterval(timer); 暂停 和 继续 主要是靠一个功能变量来记录上一个 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:2:3","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"辅助函数 用于与用户交互或操作窗口。 close() 关闭窗口 此方法可直接关闭当前窗口; alert() 显示一个带有消息和确定按钮的对话框。它的主要用途是向用户显示一些提示信息或警告信息。它的入参是一个字符串，表示要显示的消息内容。它没有返回值 alert(\"Hello World\"); confirm() 显示一个带有消息和确定按钮和取消按钮的对话框。它的主要用途是向用户询问一些需要确认或拒绝的操作。它的入参是一个字符串，表示要显示的消息内容。它的返回值是一个布尔值，表示用户点击了确定按钮还是取消按钮 // 显示一个对话框，内容为 Are you sure? var result = confirm(\"Are you sure?\"); // 根据用户的选择，打印出不同的消息 if (result) { console.log(\"You clicked OK\"); } else { console.log(\"You clicked Cancel\"); } prompt() 显示一个带有消息和输入框和确定按钮和取消按钮的对话框。它的主要用途是向用户请求一些输入信息。它的入参有两个：第一个是一个字符串，表示要显示的消息内容，第二个是可选的，表示输入框的默认值。它的返回值是一个字符串，表示用户输入的内容，或者是 null，表示用户点击了取消按钮 // 显示一个对话框，内容为 What is your name?，输入框的默认值为 John var name = prompt(\"What is your name?\", \"John\"); // 根据用户的输入，打印出不同的消息 if (name) { console.log(\"Hello, \" + name); } else { console.log(\"You did not enter your name\"); } close() 关闭当前浏览器窗口或标签页。它没有入参和返回值 // 关闭当前浏览器窗口或标签页 close() open() 打开新窗口并访问网页 open(\"https://www.baidu.com\") ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:2:4","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"navigator navigator 对象是 JavaScript 中的一个内置对象，它表示用户代理（浏览器）的状态和标识(包含有关浏览器的信息)。 它可以用于获取浏览器相关的信息和功能(获取用户客户端环境)。 可以直接使用 navigator 作为全局对象。 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:3:0","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"查看navigator 对象 查看navigator 对象\r","date":"2023-08-03","objectID":"/posts/javascript/js_window/:3:1","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"常用属性 userAgent console.log(navigator.userAgent) 表示浏览器的用户代理信息，也就是浏览器的类型、版本、操作系统等。你可以用这个属性来检测用户使用的是什么浏览器，或者做一些针对不同浏览器的兼容性处理。 language console.log(navigator.language) 表示用户设置的首选语言，通常是浏览器界面的语言。你可以用这个属性来判断用户使用的是什么语言，或者做一些针对不同语言的本地化处理 geolocation 这个属性返回一个Geolocation对象，可以用来获取用户的地理位置信息，比如经度、纬度、海拔等。 geolocation有三个方法getCurrentPosition()，watchPosition()， clearWatch() 这三个方法的功能和用途,下面分别介绍 getCurrentPosition() 可以获取设备的当前位置，这方法接收两个函数类型的参数successCallback和errorCallback ; successCallback参数有个Position 对象，该对象包含经度、纬度、精度等属性。 errorCallback参数有一个error对象，该对象包含了获取位置信息失败的原因； \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cstyle\u003e \u003c/style\u003e \u003cbody\u003e \u003cdiv id=\"demo\"\u003e \u003cspan class=\"nav-sub\"\u003e\u003c/span\u003e \u003cbutton onclick=\"getLocation()\"\u003e获取位置信息\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript\u003e const x = document.getElementById(\"demo\"); // 获取显示位置信息的元素 function getLocation() { // 定义获取位置的函数 if (navigator.geolocation) { // 检查浏览器是否支持 Geolocation navigator.geolocation.getCurrentPosition(showPosition, showError); // 调用 getCurrentPosition 方法，传入成功和错误回调函数 } else { x.innerHTML = \"该浏览器不支持获取地理位置。\"; // 如果不支持，显示提示信息 } } function showPosition(position) { // 定义成功回调函数 x.innerHTML = \"纬度: \" + position.coords.latitude + \"\u003cbr\u003e经度: \" + position.coords.longitude; // 在网页上显示经纬度 } function showError(error) { // 定义错误回调函数 switch (error.code) { // 根据错误码显示不同的提示信息 case error.PERMISSION_DENIED: x.innerHTML = \"用户拒绝了获取地理位置的请求。\" break; case error.POSITION_UNAVAILABLE: x.innerHTML = \"无法获取当前位置信息。\" break; case error.TIMEOUT: x.innerHTML = \"获取位置信息超时。\" break; case error.UNKNOWN_ERROR: x.innerHTML = \"发生了未知错误。\" break; } } \u003c/script\u003e \u003c/html\u003e watchPosition() clearWatch() watchPosition():注册一个位置变化的监听器，每当设备位置发生变化时，就会返回一个 Position 对象。你需要传入同样的参数，以及一个返回值，表示监听器的 ID。这个方法的主要用途是在需要实时监控位置变化的场景下使用，比如跟踪运动轨迹、显示实时地图等 clearWatch()：取消由 watchPosition 注册的监听器，你需要传入监听器的 ID。这个方法的主要用途是在不需要继续监控位置变化时使用，比如停止运动、关闭地图等。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cstyle\u003e \u003c/style\u003e \u003cbody\u003e \u003cdiv id=\"demo\"\u003e \u003cspan class=\"nav-sub\"\u003e\u003c/span\u003e \u003cbutton onclick=\"startWatch() \"\u003e获取位置信息\u003c/button\u003e \u003cbutton onclick=\"stopWatch() \"\u003e停止位置信息\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript\u003e var x = document.getElementById(\"demo\"); // 获取显示距离信息的元素 var watchId; // 定义监听器 ID 的变量 var prevPos; // 定义上一次位置信息的变量 function startWatch() { // 定义开始监听位置变化的函数 if (navigator.geolocation) { // 检查浏览器是否支持 Geolocation watchId = navigator.geolocation.watchPosition(showDistance, showError); // 调用 watchPosition 方法，传入成功和错误回调函数，并保存监听器 ID } else { x.innerHTML = \"该浏览器不支持获取地理位置。\"; // 如果不支持，显示提示信息 } } function stopWatch() { // 定义停止监听位置变化的函数 if (watchId) { // 检查是否有有效的监听器 ID navigator.geolocation.clearWatch(watchId); // 调用 clearWatch 方法，传入监听器 ID，取消监听 watchId = null; // 将监听器 ID 设为 null prevPos = null; // 将上一次位置信息设为 null } } function showDistance(position) { // 定义成功回调函数 if (prevPos) { // 检查是否有上一次位置信息 var distance = getDistance(prevPos.coords, position.coords); // 调用自定义的 getDistance 函数，计算两个位置之间的距离，单位为米 x.innerHTML = \"你已经移动了 \" + distance + \" 米。\"; // 在网页上显示移动的距离 } prevPos = position; // 将当前位置信息保存为上一次位置信息 x.innerHTML = \"你已经移动了 \" + prevPos.coords.latitude + prevPos.coords.longitude + \" 米。\"; // 在网页上显示移动的距离 } function showError(error) { // 定义错误回调函数 // 同上 } function getDistance(p1, p2) { // 定义计算两个位置之间距离的函数，使用 Haversine 公式 var R = 6371e3; // 地球半径，单位为米 var lat1 = p1.latitude * Math.PI / 180; // 将第一个位置的纬度转换为弧度 var lat2 = p2.latitude * Math.PI / 180; // 将第二个位置的纬度转换为弧度 var dLat = (p2.latitude - p1.latitude) * Math.PI / 180; // 计算两个位置的纬度差，转换为弧度 var dLon = (p2.longitude - p1.longitude) * Math.PI / 180; // 计算两个位置的经度差，转换为弧度 var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2); // 计算 Haversine 公式中的 a var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); // 计算 Haversine 公式中的 c var d = R * c; // 计算 Haversine 公式中的 d，即两个位置之间的距离，单位为米 return d; } \u003c/script\u003e \u003c/html\u003e Tip\r你可以用这个属性来实现一些基于位置的功能，比如导航、地图、天气等。你需要注意，这个属性需要用户授权才能使用，并且只能在安全的页面（HTTPS）上使用 console.log(position) 如果不了解position参数，可以打印查看 mediaDevices 可以用来访","date":"2023-08-03","objectID":"/posts/javascript/js_window/:3:2","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"常用方法 sendBeacon() 可以在浏览器关闭或切换页面时，向指定的url发送一些数据，比如统计信息、日志信息等。这个方法不会阻塞浏览器的卸载过程，也不会影响用户体验。 vibrate() 可以让设备产生振动效果，比如在游戏、通知、警告等场景中使用。pattern参数是一个数组，表示振动和停止的时间间隔，单位是毫秒 share() 可以让用户分享一些文本、链接、图片等内容到其他应用或平台，比如微信、微博、QQ等。data参数是一个对象，包含title、text、url等属性。你需要注意，这个方法只能在支持Web Share API的浏览器中使用，并且需要用户手动触发 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:3:3","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"document document 对象是一个表示当前网页的对象，它有许多属性和方法可以用来获取和操作文档的内容、结构和样式。根据你的要求，我将 * document* 的属性和方法按以下几个类别进行介绍 ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:4:0","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"文档对象(DOM元素) 获取DOM元素 在document中有多种方式可以获取DOM元素主要方法有 // 获取一个 document.querySelector(); // 获取匹配到的全部 document.querySelectorAll(); 该函数接收CSS选择器的字符串，返回一个HtmlElement对象;未匹配到时，返回null 通过ID获取需要使用#代表，通过id选择 \u003cbody\u003e \u003cdiv id=\"demo\"\u003e \u003cinput type=\"text\"\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript \u003e let paragraph = document.querySelector(\"#demo\"); console.log(paragraph) \u003c/script\u003e 通过Class获取需要使用.代表，通过Class选择 \u003cbody\u003e \u003cdiv class=\"demo\"\u003e \u003cinput type=\"text\"\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript \u003e let paragraph = document.querySelector(\".demo\"); console.log(paragraph) \u003c/script\u003e 通过子代组合器获取 \u003cbody\u003e \u003cul\u003e \u003cli\u003e1\u003c/li\u003e \u003cli\u003e2\u003c/li\u003e \u003cli\u003e3\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003cscript \u003e let paragraph1 = document.querySelector(\"ul \u003e li:nth-child(1)\"); let paragraph2 = document.querySelector(\"ul \u003e li:nth-child(2)\"); console.log(paragraph) console.log(paragraph2) \u003c/script\u003e Note\r选择器之间可以交替使用 \u003cbody\u003e \u003cdiv id=\"demo\"\u003e \u003cdiv id=\"demo2\"\u003e \u003cinput type=\"text\" placeholder=\"1\"\u003e \u003cinput type=\"text\" placeholder=\"2\"\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript\u003e let paragraph = document.querySelector(\"#demo #demo2 input:nth-child(2) \"); // 监听鼠标移动事件 paragraph.addEventListener(\"mouseleave\", function () { console.log(111) }) \u003c/script\u003e ","date":"2023-08-03","objectID":"/posts/javascript/js_window/:4:1","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"文档事件 事件添加 通过选择器获取htmlElement对象，然后调用addEventListener该函数入参有两个，第一个是指定事件的类型和事件的执行函数；执行函数有一个event对象,该对象叫做事件对象； let paragraph = document.querySelector(\"#demo\"); // 监听鼠标移动事件 paragraph.addEventListener(\"mouseleave\",function (event) { console.log(111) }) 事件对象 事件对象（Event Object）具有许多常用的属性和方法，可以用于处理事件的相关信息。以下是一些常用的事件对象属性和方法： 属性： event.target：获取触发事件的元素。 event.type：获取事件的类型。 event.key：获取按下的键的标识符。 event.clientX 和 event.clientY：获取鼠标指针相对于浏览器窗口可视区域的水平和垂直坐标。 event.pageX 和 event.pageY：获取鼠标指针相对于整个文档页面的水平和垂直坐标。 方法： event.preventDefault()：阻止事件的默认行为。 event.stopPropagation()：停止事件的捕获和事件冒泡。 事件流 事件流包含两个阶段：事件的捕获与冒泡，只能选择其中一个阶段 捕获 ： 当触发一个事件时，该事件会从DOM对象开始先执行，然后在向内部节点执行； Note\r当点击c2的div时，会触发click事件， 事件执行过程为 先执行document 对象监听的click事件，然后执行c1的点击事件，最后执行c2的点击事件 \u003cdiv class=\"c1\" onclick=\"f1\"\u003e \u003cdiv class=\"c2\" onclick=\"f2\"\u003e \u003c/div\u003e \u003c/div\u003e 这个由外向内的过程称为：捕获 冒泡：该阶段与捕获阶段相反，先执行被点击的节点的点击事件，再往父级执行，最后执行document的click事件,整个过程为 由内向外 事件委托 这是类似一种设计模式，通过事件流的冒泡实现，设计思路为将事件绑定到父级中，当子级触发事件时，通过冒泡方式到父级上，父级可以通过事件对象来操控所有子级对象；从而减少代码量 \u003cbody\u003e \u003cul\u003e \u003cli\u003el1\u003c/li\u003e \u003cli\u003el2\u003c/li\u003e \u003cli\u003el3\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003cscript\u003e let paragraph = document.querySelector(\"ul\"); paragraph.addEventListener(\"click\",function (ev) { if (ev.target.targetName === \"LI\"){ if (ev.target.style.color ==='red'){ ev.target.style.color ='black' return } ev.target.style.color ='red' }}) \u003c/script\u003e 事件类型 基本事件\r","date":"2023-08-03","objectID":"/posts/javascript/js_window/:4:2","tags":["javascript"],"title":"js - window对象详解","uri":"/posts/javascript/js_window/"},{"categories":["javascript"],"content":"数组 ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:0","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"什么是数组？ 数组是值的有序集合; JavaScript 数组Array可以包含任意数据类型，并通过索引来访问每一个元素。 ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:1","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"数组特点 数组定义时无需指定数据类型，无需指定数组长度，可以存储任何数据类型的数据； 数组成员可以是任何类型的值(原始类型,对象类型(包括数组),函数类型)； 如果数组的成员的值也是数组,那么就构成了多维数组.多维数组是变长的。 ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:2","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"创建数组 const arr = []; // 空数组 // 字面量：数组可以存放任意数据； const arr2 = [1,\"1\",{id:1},[\"test\",3]]; ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:3","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"添加元素 const arr = []; // 空数组 arr[arr.length] = 1; // 在末尾添加 arr[arr.length] = 2; console.log(arr); // [ 1, 2 ] ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:4","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"访问和修改元素 const arr2 = [1,\"1\",{id:1},[\"test\",3]]; console.log(arr2[1]); // 1 console.log(arr2[0]); // 1 arr2[0] = {id :10}; console.log(arr2[0]); // {id :10} Tip\r数组的 length 属性和数值属性是连接的，修改其中一个会影响另一个。特别是，减少 length 属性会删除数组的尾部元素; const arr2 = [1,\"1\",{id:1},[\"test\",3]]; console.log(arr2.length) // 4 arr2.length = 3 console.log(arr2) // [ 1, '1', { id: 1 } ] arr2.length = 10 console.log(arr2) // [ 1, '1', { id: 1 }, \u003c7 empty items\u003e ] console.log(arr2[7]) // undefined console.log(arr2[20]) // undefined 如果通过下标访问得到的值是undefined,那么大概率是数组越界了，因为一般不会像 arr2.length = 10这样去赋值数组的长度； ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:5","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"迭代方式 for const arr2 = [1,\"1\",{id:1},[\"test\",3]]; for(var i = 0; i \u003c arr2.length; i++) { console.log(arr2[i]); } // 1 // 1 // { id: 1 } // [ 'test', 3 ] const arr2 = [1,\"1\",{id:1},[\"test\",3]]; // 先缓存 arr2.length for(var i = 0, len = arr2.length; i \u003c len; i++) { console.log(arr2[i]); } for-of const arr2 = [1,\"1\",{id:1},[\"test\",3]]; for(let item of arr2) { console.log(item); } // 1 // 1 // { id: 1 } // [ 'test', 3 ] forEach() 用来遍历数组中的每一项，不影响原数组，性能差 缺点： 无法使用return返回元素,因为返回后会被forEach函数接受； 函数内部不能使用 break const arr2 = [1,\"1\",{id:1},[\"test\",3]]; arr2.forEach( function(item) { // break console.log( item); // if (item ===1) { // return item; // } }) map() 相当与原数组克隆了一份,把克隆的每项改变了,不影响原数组 const arr2 = [1,\"1\",{id:1},[\"test\",3]]; const newarr = arr2.map( function(item) { console.log(item); item = 1 return item; }) console.log(arr2); // [1,\"1\",{id:1},[\"test\",3]] console.log(newarr); // [ 1, 1, 1, 1 ] ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:6","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["javascript"],"content":"常规操作 改变原数组的方法 pop() 末尾取出 从末尾取出一个元素,此函数会返回被取出元素 const arr2 = [1,\"1\",{id:1},[\"test\",3]]; console.log(arr2.pop()); // [\"test\",3] console.log(arr2); // [ 1, '1', { id: 1 } ] push() 末尾添加 从末尾添加一个元素,此函数会返回添加元素后的数组长度; const arr2 = [1, \"1\"]; const arr3 = [23, 23]; // 添加 \"test\" 元素 arr2.push(\"test\"); console.log(arr2) // [ 1, '1', 'test' ] // 将 arr3 数组作为一个元素添加 arr2.push(arr3); console.log(arr2) // [ 1, '1', 'test', [ 23, 23 ] ] // 遍历 arr3 的每个元素顺序添加到 arr2 数组中 arr2.push(...arr3); console.log(arr2) // [ 1, '1', 'test', [ 23, 23 ], 23, 23 ] unshift() 头部添加 从元素的头部添加数据,此函数会返回添加元素后的数组长度; const arr2 = [1, \"1\"]; const arr3 = [23, 24]; // 添加 \"test\" 元素 arr2.unshift(\"test\"); console.log(arr2) // [ 'test', 1, '1' ] // 将 arr3 数组作为一个元素添加 arr2.unshift(arr3); console.log(arr2) // [ [ 23, 23 ], 'test', 1, '1' ] // 遍历 arr3 的每个元素顺序添加到 arr2 数组中 arr2.unshift(...arr3); console.log(arr2) // [ 23, 24, [ 23, 24 ], 'test', 1, '1' ] Tip\r当通过 ...arr3 的方式写入时,写入元素的顺序与arr3的顺序是一致的; // 遍历 arr3 的每个元素顺序添加到 arr2 数组中 arr2.unshift(...arr3); console.log(arr2) // [ 23, 24, [ 23, 24 ], 'test', 1, '1' ] shift() 头部删除 从头部删除元素,此函数会返回被删除的元素; const arr2 = [1, \"1\"]; console.log(arr2.shift()) // 1 console.log(arr2) // [ '1' ] reverse() 数组翻转 数组元素翻转,此函数会返回翻转后的数组; const arr2 = [1, 2, 3, 4]; console.log(arr2.reverse()) // [ 4, 3, 2, 1 ] console.log(arr2) // [ 4, 3, 2, 1 ] sort() 排序 数组排序,接受更改排序方式函数;此函数会返回排序后的数组; const arr2 = [2,1,4, 3]; console.log(arr2.sort()) // [ 1, 2, 3, 4 ] console.log(arr2) // [ 1, 2, 3, 4 ] // 倒序 console.log(arr2.sort((a, b)=\u003e {return b-a})) // [ 4, 3, 2, 1 ] console.log(arr2) // [ 4, 3, 2, 1 ] Tip\r更改排序方式案例: const arr2 = [{id: 1,name:\"jack\"},{id: 2,name:\"tom\"},{id: 3,name:\"bob\"}, {id: 4,name:\"anni\"}]; // 倒序 console.log(arr2.sort((a, b)=\u003e {return b.id-a.id})) // [ 4, 3, 2, 1 ] 不改变原数组的方法 concat() 数组合并 合并接收到的元素对象, return 合并后的新数组 const arr2 = [1, \"1\"]; const arr3 = [23, 23]; // 添加 \"test\" 元素 newarr = arr2.concat(\"test\",arr3); console.log(arr2) // [ 1, '1' ] console.log(newarr) // [ 1, '1', 'test', 23, 23 ] join() 数组转String 接受任意的连接符号, return 连接后的字符串 const arr2 = [1, 2,3,4,5,6]; console.log(arr2.join(\",\")) // 1,2,3,4,5,6 console.log(typeof arr2.join(\",\")) // string indexOf() 元素查询 传入需要任意需要查询元素, return 元素所在下标；未找到时, 返回 -1 可选择从第几个下标开始查找, 默认0 const arr2 = [1, 2,3,4,3,5]; console.log(arr2.indexOf(3,0)) // 2 console.log(arr2.indexOf(0)) // -1 filter() 数组过滤 接收一个函数, 此函数接受三个值, value 原数组的每一个元素, index 对应元素的下标, array 原数组; const arr2 = [1, 2,3,4,3,5]; newarr = arr2.filter(function (value, index, array) { if (value ===1 ){ return value } }) console.log(newarr) // [1] Tip\r需要注意的是如果在过滤元素时，出现了一次返回 array 的情况, 那么就会直接得到原数组 const arr2 = [1, 2, 3, 4, 3, 5]; newarr = arr2.filter(function (value, index, array) { if (value !== 5) { return value } return array }) console.log(newarr) // [ 1, 2, 3, 4, 3, 5 ] ","date":"2023-08-03","objectID":"/posts/javascript/js/:1:7","tags":["javascript"],"title":"js - 基本数据结构","uri":"/posts/javascript/js/"},{"categories":["golang"],"content":"1 程序介绍 Go程序管理是指在开发和部署Go语言应用程序时，如何管理项目结构、依赖管理和构建过程。以下是关于Go程序管理的几个重要方面： 项目结构： Go语言推荐使用特定的项目结构来组织代码。通常，一个Go项目包含一个主包（main package）和若干个辅助包（helper packages） 。主包通常包含应用程序的入口点，而辅助包则包含可重用的功能或库。 Go项目的主包应放置在一个独立的文件夹中，并且可以包含多个源代码文件。辅助包通常位于一个或多个子文件夹中。 依赖管理： Go语言使用Go模块（Go Modules）来管理依赖关系。 Go模块是一种用于组织和版本控制Go代码的机制。它通过go.mod文件来定义项目的模块依赖关系和版本要求。 使用Go模块，你可以方便地引入、更新和管理项目所需的依赖包。Go模块还提供了版本管理和语义化版本控制，以确保项目的稳定性和可复现性。 构建和编译： Go语言提供了内置的构建工具来编译和构建Go程序。你可以使用\"go build\"命令编译整个项目，生成可执行文件。 可以使用\"go install\"命令将可执行文件安装到系统的bin目录中，以便于全局调用。 Go还支持交叉编译，允许你在一个平台上构建针对不同操作系统和体系结构的可执行文件。 文档和测试： 在Go项目中，编写文档注释是一种良好的实践。Go语言提供了内置的文档工具（godoc），可以根据代码注释自动生成文档。 同样，编写测试用例也是一个重要的实践。Go语言具有一个内置的测试框架，你可以编写单元测试和集成测试来确保代码的正确性和稳定性。 以上是关于Go程序管理的一些重要方面。通过合理的项目结构、良好的依赖管理和构建过程，可以帮助你更好地组织和管理Go语言应用程序的开发和部署 Tip\rGo语言命令行工具的下载地址：https://golang.org/dl/ ↗\r","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:1:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"2 命令介绍 bug ： start a bug report build ： 编译包和依赖项 clean ： 删除对象文件和缓存的文件 doc ： 显示包文档 env ： 打印Go语言的环境信息 fix ： 会把指定包中的所有Go语言源码文件中旧版本代码修正为新版本的代码,升级版本时非常有用 fmt ： 格式化go源文件 generate ： 通过处理源代码生成Go文件 get ： 下载并安装包和依赖(下载包和依赖,并对它们进行编译安装) install ： 编译并安装指定包及它们的依赖包, list ： 列出包和模块信息 mod ：管理模块 work ： 工作区管理 run ： 编译并运行Go程序 test ： 测试包 tool ： 运行指定的go工具 version ： 查看当前go语言版本 vet ： 报告包中可能出现的错误 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:2:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"3 依赖管理 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:3:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"3.1 get 3.1.1 语法 go get 是 Go 语言的一个命令，用于从远程仓库获取并安装 Go 包或命令行工具 go get -h usage: go get [-t] [-u] [-v] [packages] 下面是各个常用选项的说明： t：同时下载并安装测试所需的依赖包。 u：强制更新已经存在的包或工具到最新版本。 v：输出详细的日志信息，显示下载过程中的详细信息。 [packages]：要下载和安装的包或工具的导入路径。可以一次指定多个导入路径。 Note\rgo get -u 命令会更新当前模块的所有直接和间接依赖，也就是说，它会把所有依赖的版本都升级到最新的版本。这样做可能会导致一些不兼容的问题，因为有些依赖可能会有重大的变化或者不再维护。 go get xxx@latest 命令只会更新指定的模块 xxx 到最新的版本，而不会影响其他依赖。这样做可以避免一些不必要的风险，因为您可以更精确地控制您想要更新的模块 3.1.2 案例 go get github.com/robfig/cron/v3 go get -t -u -v github.com/robfig/cron/v3 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:3:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"3.2 list 3.2.1 语法 go list 是 Go 语言的一个命令，用于列出包或模块的信息 go list -h go list [-f format] [-json] [-m] [packages] 下面是各个选项的说明： f format：指定输出的格式。你可以使用预定义的格式字符串，也可以自定义格式。例如，{{.Name}} 可以用于输出包的名称。 json：以 JSON 格式输出结果。 m：指定操作模块而不是包。 [packages]：要列出信息的包或模块的导入路径。可以一次指定多个导入路径 3.2.2 案例 go list -f \"{{.ImportPath}}\" go.uber.org/zap/... // 返回 go.uber.org/zap 的所有子包信息， ... 表示通配符（这对于了解包的结构非常有帮助） go list -f \"{{.Name}}\" github.com/robfig/cron/v3 // 返回返回一个字符串 cron ，由此可见，导入路径与包名并不一致 go list -f \"{{.Deps}}\" github.com/robfig/cron/v3 // 返回一个数组包含了该包所有使用的依赖； go list -f \"{{.GoFiles}}\" go.uber.org/zap // 返回一个数组包含了该包所有的 .go 文件，不包含子包的信息 go list -f \"{{.Dir}}\" github.com/robfig/cron/v3 // 返回该包在本地的存放位置，包含版本信息 go list -f \"{{.ImportPath}}}{{.GoFiles}}\" go.uber.org/zap/... // 可以组合展示：查看所有子包以及子包的 .go 文件 go list -m go.uber.org/zap // 返回 go.uber.org/zap v1.25.0 go list -json go.uber.org/zap // 将 ImportPath，Name，Deps,包括 -m 等等信息以json的格式输出 Note\r一个包在 Go 中具有以下信息： 包的导入路径（Import Path）：每个包都有一个唯一的导入路径，用于在代码中引用该包。导入路径通常是一个 URL 形式的字符串，例如 github.com/example/mypackage。 包的名称（Name）：包的名称是导入路径的最后一个元素，用于在代码中引用包内的标识符。例如，在导入路径为 github.com/example/mypackage 的包中，可以使用 mypackage.SomeFunction() 来调用包中的函数。 包的依赖关系（Dependencies）：包可能依赖其他的包。依赖关系表示一个包在编译和运行时所依赖的其他包。Go 模块系统能够自动管理包的依赖关系。 包的源文件列表（Source Files）：一个包通常由多个源文件组成，这些源文件包含包内的代码。源文件列表表示包中的所有源文件。 包的文档注释（Documentation）：包可以包含文档注释，用于提供对包的说明、示例和使用方法的文档。这些文档注释通常使用 Go 的文档注释格式（以 /* */ 或 // 开头）编写。 包的可见性（Visibility）：Go 中的标识符（变量、函数、结构体等）可以是公开的或私有的。公开的标识符可以在包外部访问，而私有的标识符仅在包内部可见。 包的版本（Version）：对于使用 Go 模块的项目，包还具有版本信息。模块的版本标签用于确保代码的版本一致性和可重复性。 以上是一个包在 Go 中常见的信息。这些信息可以通过 go list 命令或其他工具来获取和查看。 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:3:2","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"3.3 mod 3.3.1 语法 go mod 是 Go 命令行工具的模块管理子命令，用于管理和操作 Go 模块。 go mod help Usage: go mod \u003ccommand\u003e [arguments] 以下是 go mod 命令的常用子命令及其功能： download：将模块及其依赖项下载到本地缓存中，以供后续构建和编译使用 edit：用于从工具或脚本中编辑 go.mod 文件，手动调整模块依赖或版本。 require: 添加,修改依赖，需要加 path@version; 例：github.com/g8rswimmer/go-twitter/v2@v2.1.5 droprequire: 删除依赖，只需要 path; 例：github.com/g8rswimmer/go-twitter/v2 replace: 替换依赖，将原有的依赖指向新的依赖,使用=号指定； 例： example.com/module=../local/example.com/module dropreplace: 删除替换依赖项，只需要前者的 path ； 例：example.com/module graph：打印模块依赖关系图，显示模块之间的依赖关系。(项目根目录下有.mod那么该项目就称为模块，没有的话就称为包) init：在当前目录中初始化一个新的模块，创建 go.mod 文件。 tidy：维护和更新模块的依赖关系，确保 go.mod 和代码中的导入一致，清理不再使用的依赖项，并检查依赖的完整性 vendor：将项目依赖的模块复制到项目的 vendor Go 会将项目所需的模块及其依赖项复制到 vendor 目录中，供后续的构建和编译使用。这样可以确保在离线或无法访问外部依赖源时，项目的构建过程仍能够顺利进行。 verify：检查模块文件和其依赖项的哈希值是否匹配，以确保模块没有被篡改或损坏 why： 以更好地理解你的项目的依赖关系，并追踪模块被引入的原因 这些命令提供了一系列功能，用于管理模块的依赖关系、版本控制和构建配置等。 3.3.2 案例 go mod download // 可下载在代码中红色导入的包 go mod tidy // 与download类似，但会整合 mod 文件和清理未使用的包 go mod vendor // 将当前的依赖加入到vendor文件中 go mod init // 初始化一个新的模块，创建 go.mod 文件。 go mod verify // 校验依赖，提高安全性 go mod edit -require github.com/g8rswimmer/go -twitter/v2@v2.1.5 // 添加,修改依赖 go mod edit -droprequire github.com/g8rswimmer/go -twitter/v2 // 删除依赖 go mod edit -replace example.com/module =../local/example.com/module // 替换依赖 go mod edit -dropreplace example.com/module // 删除替换依赖项 go mod graph // 扫描当前项目 mod 文件的所有依赖，展示包含 mod 文件的依赖项 的 mod 文件内容； go mod why github.com/g8rswimmer/go -twitter/v2 // 返回引用了该模块的项目文件 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:3:3","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"4 构建 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:4:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"4.1 build ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:4:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"4.2 install ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:4:2","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"4.3 run ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:4:3","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"4.4 tool ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:4:4","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"5 文档 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:5:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"5.1 doc 5.1.1 语法 go help doc usage: go doc [doc flags] [package |[package.]symbol[.methodOrField]] Flags: -all 显示包的所有文档 -c 符号匹配区分大小写 -cmd 即使包是一个命令包（带有main函数的库），也显示具有包文档的符号 -short 对于每个符号，只显示一行的简要表示; -src 显示符号的源代码 -u 显示未导出和导出的文档 package : 提供包的导入路径; 例： github.com/robfig/cron/v3 fmt symbol : 表示标识符（symbol）的占位符。标识符可以是函数、类型、变量、常量、接口等在Go程序中定义的命名实体; methodOrField : 方法名或字段名； all : 默认情况下，go doc命令只显示公开（exported）的标识符的文档。 c : 默认情况下，go doc命令在匹配标识符时是不区分大小写的 cmd :命令包是可执行程序的入口点，其中包含main函数。命令包通常用于构建可执行文件，而不是库。 默认情况下，go doc命令只显示非命令包的符号的文档。这意味着如果你运行go doc命令时指定的包是一个命令包，它将不会显示包中的符号文档。 short : 默认情况下，go doc命令会显示每个符号的完整文档 src : 默认情况下，go doc命令只显示符号的文档，不包括源代码。使用-src选项可以在文档中包含符号的源代码。不是所有的符号都会有源代码可用。有些符号可能是在Go语言标准库或第三方库中定义的，而源代码可能无法直接访问 这些选项提供了不同的方式来定制和获取go doc命令的输出。你可以根据需要使用这些选项的组合来满足你的查看文档的需求。 5.1.2 案例 go doc net/http.Get // 显示`http.Get`函数的文档和相关信息。 go doc net/http // 显示`http`包所有可导出的类或方法信息。 go doc -all net/http // 显示`http`包所有的类或方法信息。 5.1.3 文档结构 go doc命令的文档输出具有以下结构： 导入路径（Package Import Path）：文档输出的第一行显示了包的导入路径，指示了正在查看文档的包的位置。 摘要（Package Summary）：紧接着导入路径之后，文档输出会提供有关包的简要说明和概述。这通常是一到两行的描述，用于介绍包的功能和用途。 标识符（Symbols）：在包的摘要之后，文档输出将列出该包中的各个标识符（函数、类型、变量等）以及它们的文档。 每个标识符都以其名称开头，后面跟着标识符的类型和其他相关信息。 如果标识符有文档注释，则会在名称和类型之后显示文档注释。文档注释通常提供了关于标识符的更详细说明、用法示例、函数签名等信息。 对于某些标识符，如果使用了-src选项，则在文档输出中还会包含该标识符的源代码。 示例（Examples）：在标识符列表之后，文档输出可能会包含一些示例代码，用于演示如何使用包中的某些功能或标识符。 文档输出的结构可以根据包的复杂性和文档的详细程度而有所变化。一些包可能只包含简单的摘要和标识符列表，而其他包可能提供更详细的文档和示例代码 Go文档在线搜索工具：可以帮助你更好的搜索和查看Go语言的文档 ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:5:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"版本控制： ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:6:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"fix ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:6:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"代码管理： ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:7:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"generate ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:7:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"fmt ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:7:2","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"test ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:7:3","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"工作空间维护： ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:8:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"clean ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:8:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"work ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:8:2","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"其他： ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:9:0","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"bug ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:9:1","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"env ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:9:2","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"version ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:9:3","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang"],"content":"vet ","date":"2023-08-17","objectID":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/:9:4","tags":["golang","go"],"title":"golang - go 程序管理","uri":"/posts/golang/golang-go%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"},{"categories":["golang","database"],"content":"有[featuredImagePreview]图片时，鼠标聚焦图片展示该文字","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"1 介绍 ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:1:0","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"1. 初始化 go get github.com/redis/go-redis/v9 以简洁的方式初始化客户端 import ( \"github.com/redis/go-redis/v9\" ) var db = redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", Password: \"\", // 没有密码，默认值 //db: 0, // 默认db 0 }) ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:1:1","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2 本数据类型 ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:0","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.0 公共方法 func TestComm(t *testing.T) { // keys * :获取所有key值 keys := db.Keys(ctx, \"*\").Val() fmt.Println(keys) // exists []key :返回存在的数量 val := db.Exists(ctx, \"mykey\", \"myke1y\").Val() fmt.Println(val) // type key :返回key的数据类型 vType := db.Type(ctx, \"mykey\").Val() fmt.Println(vType) // del key :删除key ；成功1，失败0； 原子性：大值可能造成阻塞 succ := db.Del(ctx, \"mykey\").Val() fmt.Println(succ) // unlink key :删除key; 即时返回，异步执行删除任务 i := db.Unlink(ctx, \"mykey\").Val() fmt.Println(i) // ttl key :判断key是否过期; -1 永不过去；-2 已过期 duration := db.TTL(ctx, \"mykey\").Val() fmt.Println(duration) // expire key :给已存在的key设置过期时间；true ;false expire := db.Expire(ctx, \"mykey11\", time.Second).Val() fmt.Println(expire) // select indexDb : 切换数据库 i2 := db.Do(ctx, \"select\", 0).Val() fmt.Println(i2) // flushdb :清空当前数据库 do := db.Do(ctx, \"flushdb\").Val() fmt.Println(do) // flushall :清空全部数据库 i3 := db.Do(ctx, \"flushall\").Val() fmt.Println(i3) } ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:1","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.1 string var ctx = context.Background() func TestString(t *testing.T) { // set key value expir ; 设置值，可标记过期时间； set := db.Set(ctx, \"mykey12\", 0, -1) fmt.Println(set.Val()) // set key value xx : 只覆盖已存在的key b2 := db.SetXX(ctx, \"\", \"\", 0).Val() fmt.Println(b2) // setnx key value : 不存在时，设置该值 b := db.SetNX(ctx, \"\", \"\", 0).Val() fmt.Println(b) // get key : 获取值 str := db.Get(ctx, \"mykey\").Val() fmt.Println(str) // APPEND key value ; 末尾拼接字符串；返回长度 val := db.Append(ctx, \"mykey\", \"+111111\").Val() fmt.Println(val) // mget ...key ： 获取多个值，失败返回nil result := db.MGet(ctx, \"key1\", \"ke2\") fmt.Println(result.Val(), len(result.Val()), result.Err()) // mset key vaule key2 vaule : 设置多个值 result2 := db.MSet(ctx, \"key1\", \"va1\", \"key2\", \"va2\") fmt.Println(result2.Val(), len(result2.Val())) // incr key : 自增 1 i := db.Incr(ctx, \"mykey12\").Val() fmt.Println(i) // Decr key : 自减 1 i2 := db.Decr(ctx, \"mykey12\").Val() fmt.Println(i2) } ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:2","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.2 list func TestList(t *testing.T) { // lpush key ...values : 从头部写入数据 lPush := db.LPush(ctx, \"lpush\", \"v1\", \"v2\").Val() fmt.Println(lPush) // rpush key ...values : 从尾部写入数据 rpsh := db.RPush(ctx, \"rpush\", \"var\", \"var2\", \"var3\").Val() fmt.Println(rpsh) // lrange key index stop : 遍历数组元素 val := db.LRange(ctx, \"lpush\", 0, -1).Val() fmt.Println(val) // rpop key : 从数据右边getDel一个元素 s := db.RPop(ctx, \"rpush\").Val() fmt.Println(s) // lindex key index : 下标访问数组元素 index := db.LIndex(ctx, \"rpush\", 0).Val() fmt.Println(index) // llen key : 返回数组长度 cmd := db.LLen(ctx, \"rpush\").Val() fmt.Println(cmd) // rpoplpush sourcesKey targetKey : 将源key的一个尾部元素，添加到目标key的头部 s2 := db.RPopLPush(ctx, \"lpush\", \"rpush\").Val() fmt.Println(s2) // } ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:3","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.3 set func TestSet(t *testing.T) { // sadd key ...value : 元组添加元素； 自动去重 val := db.SAdd(ctx, \"set1\", []string{\"222\", \"{123}\", \"{1232}\", \"123\", \"1233\"}).Val() fmt.Println(val) // srem key1 memners : 从集合中删除指定的元素 db.SRem(ctx, \"set1\", \"111\", 111) // SMembers key value : 判断value 是否存在 member := db.SIsMember(ctx, \"set1\", \"11\").Val() fmt.Println(member) // scard key: 获取数组长度 i := db.SCard(ctx, \"set1\").Val() fmt.Println(i) // spop key : 随机吐出1个元素 s := db.SPop(ctx, \"set1\").Val() fmt.Println(s) // spop key N : 随机吐出N个元素 i2, _ := db.SPopN(ctx, \"set1\", 2).Result() fmt.Println(i2) // sRandMember key : 随机获取1个元素 randMember, _ := db.SRandMember(ctx, \"set1\").Result() fmt.Println(randMember) // smove key1 key2 value : 将key1里面的value移动到key2 move := db.SMove(ctx, \"set1\", \"set2\", []int{222, 222}).Val() fmt.Println(move) // SMembers key value : 获取元组的所有元素 strings := db.SMembers(ctx, \"set1\").Val() fmt.Println(strings) } // 集合运算 func TestSetCal(t *testing.T) { // sdiff key1 key2 : 获取key1 有key2没有的元素 ，差集 val := db.SDiff(ctx, \"set1\", \"set2\").Val() fmt.Println(val) // sunion key1 key2 : 获取key1 和key2 都没有的元素，合集 strings := db.SUnion(ctx, \"set1\", \"se2\").Val() fmt.Println(strings) // sintercard count key1 key2 : count是参与运算的key数；返回key1 key2 都有的元素的个数；交集后的长度 i := db.SInterCard(ctx, 2, \"set1\", \"set2\").Val() fmt.Println(i) // sintercard key1 key2 : 返回key1 key2 都有的元素；交集 inter := db.SInter(ctx, \"set1\", \"set2\").Val() fmt.Println(inter) } ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:4","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.4 hash func TestHash(t *testing.T) { var user = \"user:001\" // map[string]map[string]interface{} ： hash本质是嵌套map // hset key field value : 设置值 val := db.HSet(ctx, user, \"name\", \"wangshao\").Val() fmt.Println(val) // hget key field : 获取值 name := db.HGet(ctx, user, \"name\").Val() fmt.Println(name) // hgetall key : 获取整个map m := db.HGetAll(ctx, user).Val() fmt.Println(m) // hexists key field : 判断字段是否存在 b := db.HExists(ctx, user, \"name\").Val() fmt.Println(b) // hlen key : 獲取key内 键值对数量 hLen := db.HLen(ctx, user).Val() fmt.Println(hLen) // hkeys key : 获取key内的所有键 strings := db.HKeys(ctx, user).Val() fmt.Println(strings) // hvals key : 获取key内的所有键的值 i := db.HVals(ctx, user).Val() fmt.Println(i) // hincrby key field : 对字段的值递增; 可对不存在的值增加,无法对float数增加 err := db.HIncrBy(ctx, user, \"name1\", 1).Err() if err != nil { log.Fatal(err) } // HIncrByFloat key field : 对字段的值递增; 可对不存在的值增加 err = db.HIncrByFloat(ctx, user, \"name1\", 1).Err() if err != nil { log.Fatal(err) } // Hsetnx key feild value : field不存在时，设置成功；反之，失败 err = db.HSetNX(ctx, user, \"name1\", \"name1111\").Err() if err != nil { log.Fatal(err.Error()) } } ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:5","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang","database"],"content":"2.5 zet ","date":"2023-08-17","objectID":"/posts/golang/golang-go-redis-%E5%BA%93/:2:6","tags":["golang","database"],"title":"golang - go-redis 基本使用","uri":"/posts/golang/golang-go-redis-%E5%BA%93/"},{"categories":["golang"],"content":"有[featuredImagePreview]图片时，鼠标聚焦图片展示该文字","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":" url:https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/ ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:0:0","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"第一章 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:0","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.0、调试go源代码 在goroot目录下./src/make.bash 脚本会编译 Go 语言的二进制、工具链以及标准库和命令并将源代码和编译好的二进制文件移动到对应的位置上 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:1","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.1、中间代码 将go文件编译成汇编语言 go build -gcflags -S main.go //main.go指定编译的go文件 小结： 掌握调试和自定义 Go 语言二进制的方法可以帮助我们快速验证对 Go 语言内部实现的猜想，通过最简单粗暴的 println 函数可以调试 Go 语言的源码和标准库 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:2","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"第二章 ： 编译原理 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:0","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.0 概述 Go 语言是一门需要编译才能运行的编程语言，也就是说代码在运行之前需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标机器上运行 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:1","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.1 抽象语法树(AST) 介绍 抽象语法树（Abstract Syntax Tree、AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素 简单表述 编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序是否存在一些类型不匹配的问题 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:2","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.2 指令集 介绍 x86 是目前比较常见的指令集，除了 x86 之外，还有 arm 等指令集，苹果最新 Macbook 的自研芯片就使用了 arm 指令集 类型 复杂指令集计算机（CISC）和精简指令集计算机（RISC）是两种遵循不同设计理念的指令集，从名字我们就可以推测出这两种指令集的区别： 复杂指令集：通过增加指令的类型减少需要执行的指令数； 精简指令集：使用更少的指令类型完成目标的计算任务 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:3","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.3 编译原理 编译器所在目录 #goroot/src/cmd/compile 编译器功能介绍 -编译器的前端承担着词法分析、语法分析、类型检查和中间代码生成几部分工作 -编译器后端负责目标代码的生成和优化，将中间代码翻译成目标机器能够运行的二进制机器码 编译过程 Go 的编译器在逻辑上可以被分成四个阶段： 1，词法与语法分析 2，类型检查 3，中间代码生成 4，机器代码生成 a. 词法与语法分析 词法分析：解析源代码文件，将文件中的字符串序列转换成 Token 序列 语法分析: 把Token 序列转换成有意义的结构体，即语法树(AST) TSPS:语法分析时，出现语法错误时会引发err b.类型检查 对语法树中定义和使用的类型进行检查: 静态类型检查 动态类型检查：动态派发、向下转型、反射以及其他特性 以下的顺序分别验证和处理不同类型的节点:1.常量、类型和函数名及类型； 2.变量的赋值和初始化； 3.函数和闭包的主体； 4.哈希键值对的类型； 5.导入函数体； 6.外部的声明； TIPS: 1.所有的类型错误和不匹配都会在这一个阶段被暴露出来，包括结构体对接口的实现 2.还会展开和改写一些内建的函数 c.中间代码生成 将输入的抽象语法树转换成中间代码 编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式 将每个语法树对应的函数进行编译：调用 cmd/compile/internal/gc.compileFunctions 进行编译，转换成中间代码 TIPS:这一阶段能够分析出代码中的无用变量和片段并对代码进行优化 d.机器码生成 机器码由CPU处理，需要根据不同的cpu使用不同的机器码生成器 在src/cmd/compile/internal 目录中包含了很多机器码生成相关的包 其中包括 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm wasm：常见的主流浏览器二进制指令格式 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:4","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.4 编译器入口 1.Go 语言的编译器入口在 src/cmd/compile/internal/gc/main.go 文件中 2.其中 600 多行的 cmd/compile/internal/gc.Main 就是 Go 语言编译器的主程序 3.该函数会先获取命令行传入的参数并更新编译选项和配置 4.随后会调用 cmd/compile/internal/gc.parseFiles 对输入的文件进行词法与语法分析得到对应的抽象语法树： ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:5","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.5 本章知识扩展 1.抽象语法树 https://en.wikipedia.org/wiki/Abstract_syntax_tree 2.静态单赋值 https://en.wikipedia.org/wiki/Static_single_assignment_form 3.编译器一般分为前端和后端，其中前端的主要工作是将源代码翻译成编程语言无关的中间表示，而后端主要负责目标代码的优化和生成。 4.指令集架构是计算机的抽象模型，也被称作架构或者计算架架构 https://en.wikipedia.org/wiki/Instruction_set_architecture 5.SourceFile 表示一个 Go 语言源文件，它由 package 定义、多个 import 语句以及顶层的声明组成 https://golang.org/ref/spec#Source_file_organization 6.关于 Go 语言文法的是不是 LALR(1) 的讨论 https://groups.google.com/forum/#!msg/golang-nuts/jVjbH2-emMQ/UdZlSNhd3DwJ 7.LALR 的全称是 Look-Ahead LR，大多数的通用编程语言都会使用 LALR 的文法 https://en.wikipedia.org/wiki/LALR_parser 8.WebAssembly 是基于栈的虚拟机的二进制指令，简称 Wasm https://webassembly.org/ 9.plugin: add Windows support #19282 https://github.com/golang/go/issues/19282 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:6","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.6 小结 编译过程： 1.词法分析：将源文件的代码进行正则匹配分组；lex3 是用于生成词法分析器的工具 2.语法分析：通过形式文法将字符分组转换成token序列，将每个函数得到输出成语法树 3.类型检查：在语法书中进行类型检查包括静态类型检查和动态类型检查 4.中间代码：根据传入cpu架构通过SSA将语法书转换成SSA特性的中间代码 5.机器码生成：根据目标机器的指令架构将中间代码通过对应架构的汇编语言器生成机器码，最后生成可以执行的二进制文件。 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:7","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"第三章：数据结构 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:0","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.0 数组 特性 1.数组在内存中都是一连串的内存空间 2.数组是由相同类型元素的集合组成的数据结构 3.通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组 4.数组长度为固定长度 初始化 方式一： arr1 := [3]int{1, 2, 3} 底层机制： var arr [3]int arr1[0]=1 arr1[1]=2 arr1[2]=3 小结：变量的类型在编译进行到类型检查阶段就会被提取出来，随后使用types.NewArray函数创建包含数组大小的结构体 方式二： arr2 := [...]int{1, 2, 3} 底层机制：通过遍历元素的方式来计算数组中元素的数量 访问和赋值 访问错误： 1.访问数组的索引是非整数时报错 2.访问数组的索引是负数时报错 3.访问数组的索引越界时报错 tips:如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，则出现的错误为运行错误; 赋值：数组的操作在编译期间为直接读写内存 arry1[i]=2 arry2 =arry1 ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:1","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["golang"],"content":"1.2 切片 特性 1.动态数组，其长度并不固定，向切片中追加元素，在容量不足时自动扩容 2.声明方式:切片的长度是动态的，声明只需要指定切片中的元素类型 数据结构 type SliceHeader struct { Data uintptr //数组的指针：指针传值 Len int //切片的长度：已存放元素数量 Cap int //切片的容量：可存放元素容量 } 切片初始化 方式一：将数值转换成切片或者获得一部分 var arr =[8]int{1,2,3,4,5} slice1 :=arr[:] slice1 :=arr[0:3] 注意事项：1，arr是数组，没有append方法； ​ 2，slice1是切片，可以使用append方法，并且slice1会自动扩容 ​ 3，slice1只能使用append方法添加元素 ​ 4，slice1是指向arr的切片，修改slice1的值，arr中的值也会被修改 ​ 5，arr的8是初始化数组长度，5元素后面的元素用0代替 ​ 6，slice1的cap满后会以两个cap的数量自动扩容 方式二：声明一个不定长数组 slice := []int{1, 2, 3} 方式三：使用make定义一个切片 slice :=make([]int,10) ","date":"2023-08-16","objectID":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:2","tags":["golang"],"title":"go语言设计与实现","uri":"/posts/golang/gl%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["javascript"],"content":"vue 插值\u0026指令 \u003cdiv id=\"root\"\u003e \u003c!-- 可执行js表达式 插值语法： 文本 指令语法： 标签 --\u003e \u003ch1\u003ehello,{{name}},{{Date.now()}}\u003c/h1\u003e \u003ca v-bind:href=\"url\" \u003e qeqwe\u003c/a\u003e \u003ca :href=\"url\" \u003e qeqwe\u003c/a\u003e \u003c!-- v-bind 简写--\u003e \u003c!-- 双向数据绑定： v-model --\u003e \u003cinput v-model:value=\"name\"\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root', data() { return { name :'插值语法', url:'指令语法' } } }) \u003c/script\u003e 数据处理 \u003cscript\u003e var bun = 2 let per = { name:'123', age:'ww', } // 数据代理模型 Object.defineProperty(per,'gender',{ value:1, enumerable:true, // 支持遍历 writable:true, // 支持修改 configurable:true, // 支持删除 get(){ // 返回bun的值 return bun }, set(va){ // 将收到的参数传给bun ， bun = va } }) \u003c/script\u003e 事件处理 \u003cdiv id=\"t\"\u003e \u003c!-- 鼠标事件： 1. @click.prevent 阻止默认事件 2. @click.stop 阻止事件冒泡 3. @click.once 只执行一次 4. @click.self 事件target为自己时触发 --\u003e \u003cbutton @click=\"show\" \u003e点我\u003c/button\u003e \u003ca href=\"http://localhost:8080\" @click.prevent=\"show\"\u003e点我跳转\u003c/a\u003e \u003c!-- 键盘事件： 1. enter 回车 2. delete 删除 3. esc 退出 4. space 空格 5. tab 换行 (必须与) 6. up 上 7. down 下 8. left 9. right 右 使用： keyup:可以实现按键组合 keydown：单键 --\u003e \u003cinput type=\"text\" placeholder=\"回车提示\" @keyup.enter=\"show\"\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#t', methods:{ show(e){ alert(e.target.value) } } }) \u003c/script\u003e 属性 computed：计算属性 watch：监视属性 \u003cdiv id=\"t\"\u003e 姓： \u003cinput type=\"text\" v-model:value=\"firstName\" \u003e 名： \u003cinput type=\"text\" v-model:value=\"lastName\" \u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#t', data() { return{ firstName :'ww', lastName :'w' } }, //计算属性计算 computed:{ // fullName:{ // get(){ // return this.firstName +'-'+this.lastName // } // } fullName(){ return this.firstName +'-'+this.lastName } }, // 监视属性 watch:{ firstName: { // firsName 修改后调用 handler(n,o){ console.log(n,o) } }, lastName: { // 深度监视 //可以监视多层级属性 deep:true, handler(n, o) { } } } }) \u003c/script\u003e 绑定class 样式 ","date":"2023-08-01","objectID":"/posts/javascript/vue/:0:1","tags":["javascript"],"title":"js - vue 基础语法","uri":"/posts/javascript/vue/"},{"categories":["linux"],"content":"0. 流程 1. 下载rpm包制作工具 2. 把可执行制文件成压缩包 3. 把压缩包制成rpm 4. 将rpm上传的yum源；采取自制yum源方式 1. 下载rpm包制作工具 步骤 1. yum install rpm-build 2. yum install rpmdevtools 3. rpmdev-setuptree //生成rpm工具的工作区，执行后默认在ROOT下生成rpmbuild目录 rpmbuild目录结构 build目录结构\r2. 把可执行制文件成压缩包 步骤 1. 进入SOURCES目录 2. 创建一个目录存放**可执行文件**，目录名称与版本号应与spec文件中的对应 3. 将可执行文件放入创建的目录中 4. 将创建的目录打包成压缩包 1. cd /root/rpmbuild/SOURCES 2. mkdir %{fileName}-%{version} 3. cp %{fileName} /root/rpmbuild/SOURCES/%{fileName}-%{version} 4. tar -zcvf %{fileName}-%{version}.tar.gz %{fileName}-%{version} 3. 把压缩包制成rpm 步骤 1. 进入SPECS目录，创建并编辑spec文件 2. 使用工具构建rpm包 1. touch %{fileName}.spec 2. rpmbuild -bb %{fileName}.spec spec文件详解 %define __debug_install_post \\ %{_rpmconfigdir}/find-debuginfo.sh %{?_find_debuginfo_opts} \"%{_builddir}/%{?buildsubdir}\"\\ %{nil} Name:app Version:1.0.1 Release:6%{?dist} Summary:app-1.0.1 Group:Applications/System License:GPL Source0:%{name}-%{version}.tar.gz %description this is app-1.0.1 %prep %setup -q %build %install mkdir -p ${RPM_BUILD_ROOT}/usr/bin cp -f ./%{name} ${RPM_BUILD_ROOT}/usr/bin/ %post %clean %files /usr/bin/%{name} %defattr(-,root,root,-) %doc %changelog rpmbuild 构建详解 rpmbuild构建详解\r找到RPM文件： [root@localhost ~]# ll rpmbuild/RPMS/x86_64/ total 476 -rw-r--r--. 1 root root 485768 Sep 16 20:14 main-v0.0.1-1.el7.x86_64.rpm 测试安装: rpm -ivh rpmbuild/RPMS/x86_64/main-v0.0.1-1.el7.x86_64.rpm 远程安装： [test_base] name=test_base_res baseurl=ftp://47.94.170.239/pub/base gpgcheck=0 4. 将rpm上传的yum源 步骤 1. 安装并启动ftp服务;安装本地仓库搭建工具createrepo 2. 在ftp目录下，创建本地yum仓库 3. 编写yum源配置 1. yum install vsftpd \u0026\u0026 service vsftpd restart 2. cd /var/ftp/pub \u0026\u0026 mkdir base \u0026\u0026 createrepo ./base 编写yum源配置 [test_base] name=test_base_res baseurl=ftp://47.94.170.239/pub/base/ gpgcheck=0 enabled=1 [test_epel] name=test_epel_res baseurl=ftp://47.94.170.239/pub/epel gpgcheck=0 enabled=1 5. 扩展功能 软件名重复 自动更新 手动更新 ubuntu 1. ubuntu20.04开启SSH远程登录 默认情况下，首次安装Ubuntu时，不允许通过SSH进行远程访问。以root 用户或具有sudo特权的用户执行以下步骤，以在Ubuntu系统上安装并启用SSH： 打开终端并安装openssh-server软件包 sudo apt update sudo apt install openssh-server 出现提示时，输入密码，然后按Enter继续安装。 安装完成后，SSH服务将自动启动。您可以通过键入以下命令来验证SSH是否正在运行： sudo systemctl status ssh 输出应告诉您该服务正在运行，并已启用以在系统引导时启动： ● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2022-09-17 05:47:27 UTC; 3h 2min ago Process: 1710 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS) Main PID: 1721 (sshd) Tasks: 1 (limit: 4625) CGroup: /system.slice/ssh.service └─1721 /usr/sbin/sshd -D 如果运行状态不为active(running)，需要手动开启，命令为： /etc/init.d/ssh start 修改SSH登录配置 sudo gedit /etc/ssh/sshd_config 将PermitRootLogin prohibit-password那一行修改为PermitRootLogin yes，去掉前面的#号 将port 22前面的#去掉 ","date":"2023-08-01","objectID":"/posts/linux/linuxubuntu/:0:0","tags":["linux"],"title":"linux - yum rpm包制作与发布","uri":"/posts/linux/linuxubuntu/"},{"categories":["linux"],"content":"制作deb 在任意目录下创建如上所示的目录以及文件,eg: mkdir -p /root/mydeb # 在该目录下存放生成deb包的文件以及目录 mkdir -p /root/mydeb/DEBIAN # 目录名必须大写 mkdir -p /root/mydeb/usr/bin # 指定将文件安装到根目录的/boot目录下 touch /root/mydeb/DEBIAN/control # 必须要有该文件 touch /root/mydeb/DEBIAN/postinst # 软件安装完后，执行该Shell脚本 touch /root/mydeb/DEBIAN/postrm # 软件卸载后,执行该Shell脚本 mkdir -p /root/mydeb \u0026\u0026 mkdir /root/mydeb/DEBIAN \u0026\u0026 mkdir /root/mydeb/usr/bin \u0026\u0026 touch /root/mydeb/DEBIAN/control \u0026\u0026 touch /root/mydeb/DEBIAN/postinst \u0026\u0026 touch/root/mydeb/DEBIAN/postrm control文件内容： Package: my-deb （软件名称，中间不能有空格） Version: 1 (软件版本) Section: utils （软件类别） Priority: optional （软件对于系统的重要程度） Architecture: amd64 （软件所支持的平台架构） Maintainer: xxxxxx \u003c\u003e （打包人和联系方式） Description: my first deb （对软件所的描述） postinst文件内容（ 软件安装完后，执行该Shell脚本，一般用来配置软件执行环境，必须以“#!/bin/sh”为首行，然后给该脚本赋予可执行权限：chmod +x postinst）： #!/bin/sh chmod +x main echo \"my deb\" \u003e /root/mydeb.log postrm文件内容（ 软件卸载后，执行该Shell脚本，一般作为清理收尾工作，必 须以“#!/bin/sh”为首行，然后给该脚本赋予可执行权限：chmod +x postrm）： #!/bin/sh rm -rf /root/mydeb.log 给mydeb目录打包： dpkg -b mydeb mydeb-1.deb (第一个参数为将要打包的目录名，第二个参数为生成包的名称。) root@u1804:~# dpkg -b mydeb mydeb-amd64-0.0.2.deb dpkg-deb: building package 'main-amd64' in 'mydeb-amd64-0.0.2.deb'. 安装deb包： dpkg -i mydeb-1.deb 将initrd-vstools.img复制到/boot目录下后，执行postinst， postinst脚本在/root目录下生成一个含有\"my deb\"字符的mydeb.log文件 root@u1804:~# dpkg -i mydeb-amd64-0.0.2.deb Selecting previously unselected package main-amd64. (Reading database ... 67385 files and directories currently installed.) Preparing to unpack mydeb-amd64-0.0.2.deb ... Unpacking main-amd64 (0.0.2) ... Setting up main-amd64 (0.0.2) ... 卸载deb包： dpkg -r my-deb 这里要卸载的包名为control文件Package字段所定义的 my-deb 。 将/boot目录下initrd-vstools.img删除后，执行posrm， postrm脚本将/root目录下的mydeb.log文件删除 dpkg -p my-deb: 删除配置文件 查看deb包是否安装： dpkg -s my-deb 这里要卸载的包名为control文件Package字段所定义的 my-deb 查看deb包安装在哪： dpkg -L package-name ","date":"2023-08-01","objectID":"/posts/linux/linuxubuntu/:0:1","tags":["linux"],"title":"linux - yum rpm包制作与发布","uri":"/posts/linux/linuxubuntu/"},{"categories":["linux"],"content":"一、 虚拟机 1. 概念 虚拟机概念\r","date":"2023-08-01","objectID":"/posts/linux/linux/:0:1","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"二、 目录结构 1. 根目录 * linux采用单根目录结构（不同于windos使用多根目录） 2. 二级目录 linux二级目录\r3. 常用文件功能介绍 /etc/passwd 存储帐号的文件 /etc/shadow 存储密码的文件 /etc/group 存储用户组的文件 /etc/sudoers 存放临时命令权限的用户与命令,在该文件100内添加用户和命令可使用sudo获取临时权限,该文件需用visudo编辑,使用whereis cmd 定位命令文件，并添加nopasswd： cmd /etc/profile 配置环境变量文件，设置好后使用. /etc/profile 来重新加载配置 ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:2","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"三、 命令范式 linux命令范式\r1. 文件操作 ls ls [选项] [命令参数] 选项 : -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -lh 将文件大小转为kb单位 -r 将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -A 同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录) -F 在列出的文件名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\" -R 若目录下有文件，则以下之文件亦皆依序列出 实例： ls -l s* 展示以s开头的文件 mkdir mkdir [选项] dirName 选项： -p 确保目录名称存在，不存在的就建一个 实例： mkdir -p run/test 如run文件夹不存在，创建后再创建test touch touch [选项] 参数 选项： 可通过touch --help查看 实例： touch testfile 创建一个没有格式的testfile文件 cat cat [选项] 文件路径 选项： -n 将文本内容带行号输出 -b 去除空格，带行号输出 -E 在每行结束处显示 $ 实例： cat -bE 文件路径 more more [选项] 文件路径 选项： -l 向前翻页，展示剩余行数百分比 -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容 实例： more -p 文件路径 less less [选项] 文件路径 选项： -m 显示剩余百分比 -N 显示行号 -g 只显示第一个搜索的关键词 实例： less -mNg 文件路径 输入： /字符串：向下搜索 ？字符串：向上搜索 n 查看下一个关键字 N 查看上一个关键字 b 向上翻页 d 向下翻页 Q 退出查看 u 向前翻半页 F 读取写入文件的最新内容，ctrl+C停止 head head [选项] 文件路径 选项： -q 隐藏文件名 -v 显示文件名 -c 显示字节数 -n 显示的行数 实例： head -c 20 文件路径 显示文件前20个字节数 head -n 10 文件路径 显示文件前10行文字 tail tail [选项] 文件路径 选项： -f 循环读取 -n 显示文件的尾部行内容 实例： tail -f 文件路径 默认显示文件最后10行，并实时读取文件内容 tail -n 200 文件路径 显示文件倒数200行内容 tail -n -100 文件路径 显示行数从第100行开始到尾部行 cp cp [选项] source dest || cp [选项] source directory 选项： -a 保留源文件所有属性 -f 覆盖文件 -p 将修改时间和访问权限页复制到新文件中 -r 复制文件夹下的所有文件和目录 -l 不复制文件，只生成链接文件 实例： cp 源文件名 目的文件名 复制一个文件 cp -f 源文件名 目的文件名 将源文件复制一份覆盖目的文件 cp -r sourceDir destDir 复制目录下的所有文件 mv mv [选项] source dest 选项： -u 源文件比目标文件新或者目标文件不存在时，才执行 -i 覆盖时询问 实例： mv source（文件） dest（文件） 将source名称改为dest mv source（文件） dest（目录） 移动文件到目录中 mv source（目录） dest（目录） dest存在，则移动；不存在，则更名 rm rm [选项] 文件或目录路径 选项： -i 删除前逐一询问 -f 直接删除 -r 删除目录 实例： rm 文件路径 删除文件 rm -r 目录路径 删除目录 rmdir rmdir [选项] dirName 选项： -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除 实例： rmdir -p BBB/test 将test删除后，如果BBB变成空目录，则也删除 umask umask [选项] [掩码] 选项： -S 文字的方式来表示权限掩码 实例： umask 展示当前用户的创建权限掩码；root默认为0022 umask -S 000 将U,G,O的权限都改为777 umask -S 222 将u,g,o的权限都改为555 ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:3","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"四、用户和组 1. 用户的分类 用户的分类\r2. 配置文件简介 用户配置文件\r3. 用户相关 groupadd groupadd [选项] GroupId gName -g 指定新建工作组的 id 实例： groupadd -g 344 normol 在/etc/group文件中增加一个组名为normol,id为344的key雨vaule groupmod groupmod [选项] 原组名 新组名 选项： -g 设置群组识别码 -n 设置群组名 实例： groupmod -n test runoob 将runoob改名为test groupdel groupdel [群组名称] 实例： groupdel test useradd useradd [选项] userName 选项： -c 加上备注文字；备注文字会保存在passwd的备注栏位中 -d 指定用户登入时的起始目录 -D 变更预设值;只用使用-b ,-e ,f,-g,-s -e\u003c有效期限\u003e 指定帐号的有效期限。参数应使用 YYYY-MM-DD 格式 -f\u003c缓冲天数\u003e 指定在密码过期后多少天即关闭该帐号。 -g 7 -g\u003c群组\u003e 指定用户所属的群组。 -s\u003cshell\u003e　指定用户登入后所使用的shell -m 自动建立用户的登入目录。 实例： #创建的用户信心会保存在/etc/passwd中 useradd -c turan -d /home/turan -g turanGroup turan #添加一个不能登录的用户 useradd -d /usr/local/apache -g apache -s /bin/false apache ##建立用户指定id useradd turan -u 544 usermod usermod [选项] userName 选项： -c\u003c备注\u003e 修改用户帐号的备注文字。 -d登入目录\u003e 修改用户登入时的目录。 -e\u003c有效期限\u003e 修改帐号的有效期限。 -f\u003c缓冲天数\u003e 修改在密码过期后多少天即关闭该帐号。 -g\u003c群组\u003e 修改用户所属的群组。 -G\u003c群组\u003e 修改用户所属的附加群组。 -l\u003c帐号名称\u003e 修改用户帐号名称。 -L 锁定用户密码，使密码无效。 -s\u003cshell\u003e 修改用户登入后所使用的shell。 -u\u003cuid\u003e 修改用户ID。 -U 解除密码锁定。 实例： usermod -u 300 turan //修改turan Uid为300 userdel userdel [选项] username 选项： -r 删除用户登入目录以及目录中所有文件。 实例： ##仅删除账号，不删除账号的数据 userdel turan ##账号与数据一并删除 userdel -r turan passwd passwd [选项] userName 选项： -d 删除密码 -l 停止账号的使用 -S 显示密码信息(不展示密码) -u 启用被停止的账户 -w 口令要到期提前警告的天数 -x 指定口令最长存活期 实例： passwd turan //修改用户密码，之后输入两次密码 //查看用户密码：用户名，密码状态（LK锁住,NP无密码,p可用），密码最后修改时间，失效前警告天数，密码失效时间(-1表示没有失效时间) passwd -S turan ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:4","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"五、 文件权限 1. 权限引入 文件权限引入\r文件权限引入\r2. 文件的7种类型 - 普通文件：纯文本文件(ASCII)；二进制文件(binary)； 数据格式的文件(data);各种压缩文件 d 目录文件： c 字符设备文件： b 块设备文件： s 套接字： p 管道文件： l 链接文件：快捷方式 3. 文件权限掩码 第一个rwx 表示创建者所有权限 r=4 w=2 x=1 第二个rwx 表示所属组所有权限 第三个rwx 其他成员所有权限 4. 权限相关 chown chown [选项] fileName 选项： -R 处理指定目录以及其子目录下的所有文件 实例： chown root xiaotu //将xiaotu文件或目录的所有者设置为root chown turan:turanGroup xiaotu //更改xiaotu的所有者与群体使用者 chown -R turan:turanGroup * //将当前目录下的所有文件的所有者和群使用者修改 chgrp chgrp [选项] filename 选项： -v 修改群组所有 实例： chgrp -v group filename //更改文件的群组信息 chmod chmod [选项] filename 选项： -R 递归更改目录内的所有文件 实例： chmod +r file //所有用户添加r权限 chmod o+r file //o用户增加file权限 chmod u=rw,go= file //u为rw权限,go没有任何权限 sudo sudo userName cmd 实例： sudo useradd -g gid usrname //临时普通用户使用useradd命令，配置临时命令，请查看二中的常用文件功能介绍 sudo工作流程\r5. 权限的类型 目录权限 r 读取牧区结构列表（可获取文件名） w 更改目录结构列表（新增，删除，移动，复制） x 可cd进入该目录 文件权限 r 读取文件内容 w 编辑文件内容 x 可执行文件 ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:5","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"六、 yum服务 1. 服务介绍 yum服务\r2、 yum源介绍 yum源\r3. yum源配置文件 yum源配置文件\r4. Base网络源文件介绍 yum网络源文件介绍\r5. yum常用命令 yum repolist 查看使用的代理 yum list 查询仓库中所有rnp包 ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:6","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"七 、 进程与服务 1. 程序与进程的区别 程序与进程区别\r服务\r2. 进程介绍 进程介绍\r进程介绍2\r3. 进程的分类 进程的类型\r4. 进程的状态 进程的状态\r5. 服务的分类 服务的分类\r6. 进程的管理 1. 进程监控命令 监控静态和动态的进程 ps ps [选项] 选项： -aux 显示所有包含其他使用者的行程 -ef 显示所有进程信息，连同命令行 实例： ps -ef | grep 进程名 //查找进程 可查看pid与ppid ps -aux //查看所有进程 ps -u root //查看root用户的持有进程 pstree 实例： pstree -apnh //显示进程间的关系 pstree -u //显示用户名称 top top [选项] 选项： -d 改变显示的更新速度 -c 显示完整的路径与名称 实例： top -d 3 //每三秒刷新进程信息 top -c // 显示完整的路径与名称 2. 进程控制命令 终止进程 kill kill [选项] pid 选项： -9 强制杀死 -1 重新加载进程 -15 正常终止进程 5. 服务的管理 systemdctl systemdctl [选项] 服务名 选项： start ","date":"2023-08-01","objectID":"/posts/linux/linux/:0:7","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"八、 ssh服务 1. ssh介绍 ssh介绍\r2. ssh版本 ssh版本\r3. ssh远程登录 ssh远程登录\r4. 文件上传和下载 服务的分类\r","date":"2023-08-01","objectID":"/posts/linux/linux/:0:8","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"九、 shell 1. shell介绍 shell介绍\r2. shell的类型 shell的分类\r3. bash特性 shell-bash功能\rshell通配符\r别名 alias chm='cd /home' 将命令封装为chm，使用chm可直接打开home目录 通配符 ls * ls l* ------- ls l? ls ?? ------- ls l[abcd] 4. 变量 变量\r5. 脚本 脚本\r","date":"2023-08-01","objectID":"/posts/linux/linux/:0:9","tags":["linux"],"title":"linux - 基础命令","uri":"/posts/linux/linux/"},{"categories":["linux"],"content":"有[featuredImagePreview]图片时，鼠标聚焦图片展示该文字","date":"2023-08-01","objectID":"/posts/linux/linux_installer/","tags":["linux"],"title":"linux - 软件安装","uri":"/posts/linux/linux_installer/"},{"categories":["linux"],"content":"docker 与 compose 安装docker 与 compose 请按照以下步骤进行操作： 您可以使用以下命令执行此操作： sudo yum update 安装Docker和Docker Compose的依赖项。您可以使用以下命令安装它们： sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装docker 和 compose sudo yum install docker-ce docker-ce-cli [containerd.io](http://containerd.io/) sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 确认Docker Compose是否安装成功。您可以使用以下命令检查版本： docker --version docker-compose --version 启动docker sudo systemctl start docker sudo systemctl enable docker ","date":"2023-08-01","objectID":"/posts/linux/linux_installer/:1:0","tags":["linux"],"title":"linux - 软件安装","uri":"/posts/linux/linux_installer/"},{"categories":["Markdown"],"content":"1 前置参数 以下字段为必填项： --- title: \"文章名称\" date: 2023-08-01T15:06:34+08:00 draft: false description: \"有[featuredImagePreview]图片时，鼠标聚焦图片展示该文字\" author: \"Turan\" # 标签 tags: [test] # 分类 categories: [文章编写] # 进入文章详情后的置顶图 featuredImage: \"/images/2.jpg\" # 文章外侧预览图 featuredImagePreview: \"images/1.jpg\" # 是否展示在首页 hiddenFromHomePage: false # 预览界面展示文字 summary: \"这是摘要\" # 展开所有标题 toc: auto: false --- ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:1:0","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2 内容样式语法 ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:0","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2.1 标题 文章主题（即tittle）: 不需要明确写在文章内，在前置参数内的title表明即可；为 # ； 二级标题：比文章主题小一级的标题，语法使用 ## ; 其他表示：语法以此类推；三级 ### ,四级 #### ; ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:1","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2.2 段落 段落文章不需要加任何语法，直接编写； ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:2","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2.3 样式字体 加粗： 加粗字体 **加粗字体**\r关键字： 关键字、 `关键字`\r超链接： 百度一下 [百度一下](https://www.baidu.com/)\r","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:3","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2.4 文本块 代码块：```yaml ``` 关键字：go,toml,bash… 短码文本块： type: abstract,info,tip,success,question,warning,failure,danger,bug,example,quote {{\u003c admonition type=\"note\" title=\"This is a note\" \u003e}} This is the content of the note. {{\u003c /admonition \u003e}} Note\r一个 注意 横幅\rAbstract\r一个 摘要 横幅\rInfo\r一个 信息 横幅\rTip\r一个 技巧 横幅\rSuccess\r一个 成功 横幅\rQuestion\r一个 问题 横幅\rWarning\r一个 警告 横幅\rFailure\r一个 失败 横幅\rDanger\r一个 危险 横幅\rBug\r一个 Bug 横幅\rExample\r一个 示例 横幅\rQuote\r一个 引用 横幅\r","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:4","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"2.5 引文 语法: \u003e 这是一个多行引文 这是一个多行引文 ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:2:5","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"3 多媒体 ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:3:0","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"3.1 图片 3.1.1 md 语法 语法: ![Minion](https://octodex.github.com/images/minion.png) // 站内 images 为content的子文件夹 ![navigator](/images/javascript/navigator.png) 3.1.2 image 短码 ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:3:1","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightGallery 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/Markdown/tn.png\" caption=\"Lighthouse (`image`)\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\r","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:4:0","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"3.2 图 3.2.1 思维导图 {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:4:1","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["Markdown"],"content":"4 表格 语法： 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | | :------: | :----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2023-08-01","objectID":"/posts/markdown/document_rule/:5:0","tags":["Markdown"],"title":"Markdown - 文章基本语法","uri":"/posts/markdown/document_rule/"},{"categories":["MQ"],"content":"消息队列的应用场景 1. 异步处理 秒杀系统需要解决的核心问题是，如何利用有限的服务器资源，尽可能多地处理短时间内的海量请求。我们知道，处理一个秒杀请求包含了很多步骤，例如： 风险控制； 库存锁定； 生成订单； 短信通知； 更新统计数据。 确定本次请求的秒杀结果后，就可以马上给用户返回响应，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。 异步处理\r2. 流量控制 我们需要设计一套足够健壮的架构来将后端的服务保护起来。我们的设计思路是，使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。 加入消息队列后，整个秒杀流程变为： 网关在收到请求后，将请求放入请求消息队列； 后端服务从请求消息队列中获取 APP 请求，完成后续秒杀处理过程，然后返回结果。 秒杀开始后，当短时间内大量的秒杀请求到达网关时，不会直接冲击到后端的秒杀服务，而是先堆积在消息队列中，后端服务按照自己的最大处理能力，从消息队列中消费请求进行处理。 对于超时的请求可以直接丢弃，APP 将超时无响应的请求处理为秒杀失败即可。运维人员还可以随时增加秒杀服务的实例数量进行水平扩容，而不用对系统的其他部分做任何更改。 令牌桶控制流量的原理是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。 实现的方式也很简单，不需要破坏原有的调用链，只要网关在处理 APP 请求时增加一个获取令牌的逻辑。 令牌桶可以简单地用一个有固定容量的消息队列加一个“令牌发生器”来实现：令牌发生器按照预估的处理能力，匀速生产令牌并放入令牌队列（如果队列满了则丢弃令牌），网关在收到请求时去令牌队列消费一个令牌，获取到令牌则继续调用后端秒杀服务，如果获取不到令牌则直接返回秒杀失败。 3. 服务解耦 这些订单下游的系统都需要实时获得订单数据。随着业务不断发展，这些订单下游系统不断的增加，不断变化，并且每个系统可能只需要订单数据的一个子集，负责订单服务的开发团队不得不花费很大的精力，应对不断增加变化的下游系统，不停地修改调试订单系统与这些下游系统的接口。任何一个下游系统接口变更，都需要订单模块重新进行一次上线，对于一个电商的核心服务来说，这几乎是不可接受的。 所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。 小结 以上就是消息队列最常被使用的三种场景：异步处理、流量控制和服务解耦。当然，消息队列的适用范围不仅仅局限于这些场景，还有包括： 作为发布 / 订阅系统实现一个微服务级系统间的观察者模式； 连接流计算任务和数据； 用于将消息广播给大量接收者。 同时我们也要认识到，消息队列也有它自身的一些问题和局限性，包括： 引入消息队列带来的延迟问题； 增加了系统的复杂度； 可能产生数据不一致的问题。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:1:0","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"消息模型 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:0","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"1. RabbitMQ 在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。 同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:1","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"2. RocketMQ RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:2","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"3. Kafka 我们再来看看另一种常见的消息队列 Kafka，Kafka 的消息模型和 RocketMQ 是完全一样的，我刚刚讲的所有 RocketMQ 中对应的概念，和生产消费过程中的确认机制，都完全适用于 Kafka。唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:2:3","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"事务消息 其实很多场景下，我们“发消息”这个过程，目的往往是通知另外一个系统或者模块去更新数据，消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。 1. 实现分布式事务 首先，订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。 半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求 2. 解决第四部失败问题 在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:3:0","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"可靠消息投递 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:4:0","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"1. 消息丢失 一条消息从生产到消费完成这个过程，可以划分三个阶段，为了方便描述，我给每个阶段分别起了个名字。 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。 存储阶段: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。 消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。 生产阶段 消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到 Broker，Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。 只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。 你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失 存储阶段 如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。 对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。 如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失 消费阶段 消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给 Broker 发送消费确认响应。如果 Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。 你在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。 小结 一条消息从发送到消费整个流程中，消息队列是如何确保消息的可靠性，不会丢失的。这个过程可以分为分三个阶段，每个阶段都需要正确的编写代码并且设置正确的配置项，才能配合消息队列的可靠性机制，确保消息不会丢失。 在生产阶段，你需要捕获消息发送的错误，并重发消息。 在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。 在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:4:1","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"2. 重复消息 消息重复的情况必然存在 在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是： At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。 At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。 Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。 这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息队列很难保证消息不重复。 用幂等性解决重复消息问题 利用数据库的唯一约束实现幂等 基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费 为更新的数据设置前置条件 如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。 我们可以将 HTTP 服务设计成幂等的，解决前端或者 APP 重复提交表单数据的问题；也可以将一个微服务设计成幂等的，解决 RPC 框架自动重试导致的重复调用问题。这些方法都是通用的，希望你能做到触类旁通，举一反三。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:4:2","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"消息积压该如何处理 消息积压的直接原因，一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压。在使用消息队列时，如何来优化代码的性能，避免出现消息积压 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:5:0","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"1. 优化性能 对于绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务系统的处理能力。主流消息队列的单个节点，消息收发的性能可以达到每秒钟处理几万至几十万条消息的水平，还可以通过水平扩展 Broker 的实例数成倍地提升处理能力。 一般的业务系统需要处理的业务逻辑远比消息队列要复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消息队列的性能优化，我们更关注的是，在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。 生产端优化 发送端业务代码的处理性能，实际上和消息队列的关系不大，因为一般发送端都是先执行自己的业务逻辑，最后再发送消息。如果说，你的代码发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的。 发送端可以使用批量发送或者并发发送的方式提高性能；一般微服务框架都支持并发，所以这个不用太关注，可根据业务需求选择；批量发送方式会出现一定的时延，并发发送可以做到即时响应； 我们之前的课程中讲过 Producer 发送消息的过程，Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互。假设这一次交互的平均时延是 1ms，我们把这 1ms 的时间分解开，它包括了下面这些步骤的耗时： 发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时； 发送消息和返回响应在网络传输中的耗时； Broker 处理消息的时延。 如果是单线程发送，每次只发送 1 条消息，那么每秒只能发送 1000ms / 1ms * 1 条 /ms = 1000 条 消息，这种情况下并不能发挥出消息队列的全部实力 消费端优化 使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的 。 所以，我们在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行 消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。特别需要注意的一点是，**在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。**如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。因为对于消费者来说，在每个分区上实际上只能支持单线程消费。 ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:5:1","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["MQ"],"content":"2. 解决消息挤压 能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。 大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例数来提升总体的消费能力。 如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。 还有一种不太常见的情况，你通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候你需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多，这种情况也会拖慢整个系统的消费速度。 如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。 》你在读完上面这些文档之后，对这个项目的整体应该会有一个比较全面的了解了，比如说： 这个项目是干什么的？ 能解决哪些问题？ 适合在哪些场景使用？ 有哪些功能？ 如何使用？ ","date":"2023-08-01","objectID":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/:5:2","tags":["MQ"],"title":"MQ - 《一》消息队列--基础篇","uri":"/posts/mq/%E4%B8%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97--%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":null,"content":"五层 模型 物理层 概念 通信模型 相关术语 三种通信方式 两种传输方式 码元 速率、波特、带宽 失真 奈氏准则 规定了带宽受限的最高通信波特 香农定理 规定了带宽受限有噪声的传输速率 对比 信号 编码和调制 ","date":"0001-01-01","objectID":"/posts/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:0:0","tags":null,"title":"","uri":"/posts/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":null,"content":"mysql 日志文件 重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。 ","date":"0001-01-01","objectID":"/posts/database/mysql-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/:0:0","tags":null,"title":"","uri":"/posts/database/mysql-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"GO 一、基本结构与基本数据类型 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:0:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 变量 package main import \"fmt\" //全局变量：可以不使用 var ( name string age int ) func main() { var v1 string //不赋值为零值 var v2 = 2 //自动推导无需定义类型 v3 := 23 //自动推导简写 _ := fmt.Sprintf(\"\") //匿名变量 下划线 fmt.Println(v1,v2,v3) //值类型使用只存储 s1 :=2 s2 :=s1 s1=1 fmt.Println(s2,s1) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:1:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1 常量 const beef, two, c = \"eat\", 2, \"veg\" //并行赋值 const ( const ( Mond= iota //iota表示在常量组的第几行，从零开始 Tusday Wednesday Thursday, Friday, Saturday = 4, iota, iota //两个iota都是三，因为都在第四行 dsa =iota ) ) ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:2:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 基本数据类型 Go 中不允许不同类型之间的混合使用 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:3:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"a.数字类型 //整数 int8（-128 -\u003e 127） int16（-32768 -\u003e 32767） int32（-2,147,483,648 -\u003e 2,147,483,647） int64（-9,223,372,036,854,775,808 -\u003e 9,223,372,036,854,775,807） //无符号整数： uint8（0 -\u003e 255） uint16（0 -\u003e 65,535） uint32（0 -\u003e 4,294,967,295） uint64（0 -\u003e 18,446,744,073,709,551,615） //浮点型 float32（+- 1e-45 -\u003e +- 3.4 * 1e38） 精确到小数点后7位 float64（+- 5 1e-324 -\u003e 107 1e308） 精确到小数点后15位 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:3:1","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"b.类型转换 i := int8(127) var i2 int32 i2= int32(i) //类型转换需要显示转换;不能直接 i2 =i fmt.Println(i2) v1 :=077 u := uint64(v1) //类型装换 fmt.Println(v1,u) ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:3:2","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 运算符 一元运算符： ！true 取反 ^ 按位补足 \u003c\u003c 位左移 小数点想左移动一位 \u003e\u003e 位右移 小数点想右移动一位 二运运算符： \u0026\u0026 只有当两边的值都为 true 的时候 || 一边为true，返回true；两边为false，返回false 注：当二元运算符，左侧为true，则不会运算后面的代码，可以使用()提升优先级 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:4:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 进制数表示方法 v1 :=077 //增加前缀 0 来表示 8 进制数 v2 :=0xff //增加前缀 0x 来表示 16 进制数 v3 :=0xAA V4 := 10e3 //10e3 ：表示10*（10）^3 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:5:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.5 格式化输出字符串 %d 用于格式化整数 %x 和 %X 用于格式化 16 进制表示的数字 %g 用于格式化浮点型 %f 输出浮点数，%e 输出科学计数表示法 %0d 用于规定输出定长的整数，其中开头的数字 0 是必须的 %p 指针的格式化标识符为 %s //不同编码的格式化方式 var ch int = '\\u0041' //utf-8的16进制表示方式 var ch2 int = '\\u03B2' var ch3 int = '\\U00101234' fmt.Printf(\"%d - %d - %d\\n\", ch, ch2, ch3) // integer fmt.Printf(\"%c - %c - %c\\n\", ch, ch2, ch3) // character fmt.Printf(\"%X - %X - %X\\n\", ch, ch2, ch3) // UTF-8 bytes fmt.Printf(\"%U - %U - %U\", ch, ch2, ch3) // UTF-8 code point ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:6:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.6 运算符优先级 二元运算符的运算方向均是从左至右 由上至下代表优先级由高到低 优先级 运算符 7 ^ ! 6 * / % \u003c\u003c \u003e\u003e \u0026 \u0026^ 5 + - | ^ 4 == != \u003c \u003c= \u003e= \u003e 3 \u003c- 2 \u0026\u0026 1 || ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:7:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.7 类别名 类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法 TZ 可以自定义一个方法用来输出更加人性化的时区信息 type integer int //给int起别名 var v32 integer //定义变量时可以使用别名来定义 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:8:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.8 字符串 //1.一般的比较运算符（==、!=、\u003c、\u003c=、\u003e=、\u003e）通过在内存中按字节比较来实现字符串的对比 //2.字符串是字节的定长数组，在中括号 [] 内写入索引 //3.字符串拼接使用+号，或者+=与同一个变量 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:9:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.9 strings包 func main() { s := \"w ddd dsjkdsjs dk\" s2 := \"d\" s3 :=\"22\" println(strings.HasPrefix(s, \"A\")) //判断s开头 println(strings.HasSuffix(s2, \"a\"))//判断s2结尾 println(strings.Contains(s, \"aS\")) //判断s包含 println(strings.Index(s, \"SA\"))//返回w在s的下标；不存在时，返回-1;从首字符开始算 println(strings.LastIndex(s, \"w\"))//返回w最后出现的索引位置；不存在返回-1 println(strings.Replace(s, s2, s3, 6)) //s:表示原字符穿，s2是s中的字符，s3是替换s2的值，6表示需要替换6次s2 println(strings.Count(s, \"w\")) //统计w在s中出现的次数，非重叠 println(strings.Repeat(s2, 6)) //将s2重复拼接6次 println(strings.TrimSpace(\" s d \")) //剔除字符串开头和结尾的空白符号 println(strings.Trim(\"sdds\", \"s\")) //指定去除开头和结尾的s符号 println(strings.TrimLeft(\"sdd\", \"s\")) //剔除左边的开头的字符 println(strings.Fields(\"sds ds d\")) //以空格分隔，返回一个切片 println(strings.Split(\"sdsd\", \"s\")) //指定以s分割,返回一个切片 println(strings.Join(strings.Fields(\"sds ds d\"), \"2\")) //接收一个切片，每个元素中间以2拼接 println(strings.NewReader(\"sss\")) //读取字符串内容返回reader对象 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:10:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"2.0 strconv包 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:11:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"2.1 时间与日期 （time包） ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:12:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"2.2 指针 var intP *int //定义一直只接收Int类型数据的指针 i := 2 i =3 intP =\u0026i //将i变量的指针赋值给inp *intP++ //指定值操作，会改变原来的值;通过*号取出指针的值 print(*intP,\"\\n\",intP,\"\\n\",\u0026i,\"\\n\",i) --------- //注意：不能得到一个文字或常量的地址 const i = 5 ptr := \u0026i //error: cannot take the address of i ptr2 := \u002610 //error: cannot take the address of 10 二、控制结构 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:13:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 if -else if v1:=\"22\";v1==\"22\" { //定义一个变量，分号隔开，条件判断 fmt.Println(\"true\") }else if v1==\"33\" { fmt.Println(\"false\") }else { fmt.Println(\"默认\") } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:14:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1 switch //1 switch name { //name的类型决定了case判断的类型;可以调用函数作为值的判断 case 1,2,3: //可以使用多个值并列 fmt.Println(name) case name -0,name-2: //当name类型为bool值时，可以使用比较运算符 fmt.Println(name) default: fmt.Println(\"default\",name) } //2 switch a, b := x[i], y[j]; { //平行初始化内容 case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:15:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 for for ;;{ //无限循环 fmt.Println(1) } ---------- for i := 0; i \u003c10 ; i++ { //初始值，条件，修饰 fmt.Println(i) } ---------- var name int =2 for name\u003c10{ //拿一个变量作为初始值，修饰语句写在方法体 name++ fmt.Println(name) } ---------- arry:=[]int{1,23,4,5} for index, value := range arry { //使用for range 遍历数组或map fmt.Println(index,value) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:16:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 break与continue 当函数执行到 return 语句 return 语句也可以用来结束 for 死循环或者结束一个协程（goroutine） for i:=0; i\u003c10; i++ { for j:=0; j\u003c10; j++ { if j\u003e5 { break //break只会退出最内层循环 } print(j) } print(\" \") } } --------------- func main() { for i := 0; i \u003c 10; i++ { if i == 5 { continue //跳过当前循环，进入下一个循环 } print(i) print(\" \") } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:17:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 标签与goto LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 //此写法与break作用一致 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } ------------- i:=0 HERE: print(i) i++ if i==5 { return } goto HERE //使用goto模拟循环 三、函数 当函数执行到 return 语句 return 语句也可以用来结束 for 死循环或者结束一个协程（goroutine） ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:18:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 按值传递、引用传递 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针） package main import \"fmt\" func main() { var name int =3 var v2 int =4 fmt.Println(name) modify(\u0026name) fmt.Println(name) fmt.Println(\"----------------\") fmt.Println(v2) s(v2) fmt.Println(v2) } func modify(var1 *int) { //引用传递，操作值的本身 *var1 =4 } func s(var2 int) { //按置传递，操作副本， var2=43 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:19:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1 变长函数 func main() { long1 :=[]int{1,23,4,5} long(1,23,4,5,6,7,8,99) long(long1...) //放在slice的参数需以...的方式传递 } func long(arryInt ...int) { //固定类型的变长函数 for i, i2 := range arryInt { fmt.Println(i,i2) } } ------------ func main() { long1 :=[]int{1,23,4,5} long(1,23,4,5,6,7,8,99) long(long1) //interface接口任何的数据类型，不需要... } func long(arryInt ...interface{}) { //任意长度，任意类型的边长函数 for i, i2 := range arryInt { fmt.Println(i,i2) } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:20:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 defer 与追踪 package main import \"fmt\" func main() { defer un(trace(23)) //执行顺序：trace,b,a,un defer a(b(23)) fmt.Println() } func b(v int) int{ fmt.Println(\"vb:\",v) return v } func a(v int) { fmt.Println(\"va\",a) } func trace(s int) int { fmt.Println(\"entering:\", s) return s } func un(s int) { fmt.Println(\"leaving:\", s) } -------------- func func1(s string) (n int, err error) { defer func() { //记录函数的参数与返回值 log.Printf(\"func1(%q) = %d, %v\", s, n, err) }() return 7, io.EOF } func main() { func1(\"Go\") } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:21:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 函数作为参数 func main() { callback(1, Add) } func Add(a, b int) { fmt.Printf(\"The sum of %d and %d is: %d\\n\", a, b, a+b) } func callback(y int, f func( int, int)){ f(y, 2) // 传进来的函数在内部调用，参数值可在传进入也可以自己写入 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:22:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 匿名函数 func main() { add :=func (a ,b int)(c int){ //将匿名函数赋值给一个变量 defer func() { //直接调用的匿名函数 fmt.Println(c) }() c= a+b return } add(2,3) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:23:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.5 闭包 四、数组与切片 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:24:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 数组的声明 var arry [10]int //声明一个数组，初始化为0 arry[1] =3 fmt.Println(arry) arr2 :=\u0026arry //使用指针赋值会改变原来的数值 arr2[1]=4 fmt.Println(arry,*arr2) // var arrAge = [5]int{18, 20, 15, 22, 16} var arrKeyValue = [5]string{3: \"Chris\", 4: \"Ron\"} //指定下标存值 // var arrKeyValue = []string{3: \"Chris\", 4: \"Ron\"} for i:=0; i \u003c len(arrKeyValue); i++ { fmt.Printf(\"Person at %d is %s\\n\", i, arrKeyValue[i]) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:25:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1 切片 var arrLazy = [...]int{5, 6, 7, 8, 22} var arrLazy = []int{5, 6, 7, 8, 22} func aryyM(a []int) { //切片函数} ----------------------------------------------- var arr []int //未初始化定义数组 var arr2 =make([]int,1,3) //定义3的容量，初始化长度为1 arr3 := make([]int,1,4) //初始化长度为2 fmt.Println(arr,arr2,cap(arr2),len(arr2),arr3) for i := 0; i \u003c 4; i++ { arr3 = arr3[0:i+1] //初始化长度扩容，重新定义了空间，i+1的值不能大于容量 arr3[i] =i } fmt.Print(arr3) ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:26:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 new与make new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 \u0026T{}。 make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。 五、map ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:27:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 map声明与基本使用 package main import \"fmt\" func main() { var map1 map[int]string //定义一个空map map1 = map[int]string{1: \"23\", 2: \"2323\"} //初始化值 map1[13] = \"2323\" //动态增加，未初始化的map不能动态增加key:value fmt.Println(map1, len(map1)) //----------------------------------------------------------- map2 := make(map[int]string) //直接定义一个map初始化 map2[2] = \"23\" //可直接动态增加 fmt.Println(map2) //========================================================= mf := map[int]func() int{ //func() int 表示存放的函数是返回int类型 1: func() int { return 10 }, 2: func() int { return 20 }, 5: func() int { return 50 }, } mf[3]= func() int { //添加函数 return re() } fmt.Println(mf) //---------------------------------------------------------- map3 :=make(map[int]string,5)//当map增长到容量上限的时候，如果再增加map的大小会自动加1 for i := 0; i \u003c 10; i++ { map3[i]=fmt.Sprintf(\"%d\",i+1) } fmt.Println(map3[2]) //通过key获取值 //---------------------------------------------------------- value,inpresnt := map3[2] //判断map3key为2是否存在，返回值和bool值 fmt.Println(value,inpresnt) //---------------------------------------------------------- delete(map3,2) //删除map3Key为2的键值对 fmt.Println(map3) //-------------------------------------------------------- i := make([]map[int]int,3) //给切片定义了3个map为int类型的key，value；但是里面的3个map没有开辟空间 i[1] = make(map[int]int,2) //指定数组下标有1的map初始化 i[0][2]=2 //未初始化赋值，runtime i[1][2]=2 //初始化后，可以添加key,value fmt.Println(i) //想要一个排序的列表你最好使用结构体切片 type name struct { key string value int } } func re() int{ return 10 } 六、结构体与方法 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:28:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 定义与赋值 package main import \"fmt\" func main() { var person = new(person) //使用new创建结构体，person变量是一个指针 person.tpye=\"女孩\" //类似map的赋值，指针使用的是引用赋值 person.name=\"云小卷\" //fmt.Println(*person) //--------------------- person.p() fmt.Println(person) person.pr() fmt.Println(person) } type person struct { tpye string name string } func (receiver *person) p() { //可以改变原来的属性值 receiver.name=\"伊莲\" fmt.Println(receiver.tpye+receiver.name) } func (receiver person) pr() { //不使用指针，操作为值引用， receiver.name=\"靳夏\" fmt.Println(receiver.tpye+receiver.name) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:29:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 使用工厂创建对象 func main() { person:=NewPerson(\"女孩\",\"云小卷\") //在结构体私有时，可通过工厂夸包访问 fmt.Println(*person) } func NewPerson(tpye string,name string) *person { return \u0026person{ //\u0026person等价于nwe（person） tpye: tpye, name: name, } } type person struct { tpye string name string } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:30:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 结构体继承 package main import \"fmt\" func main() { person:=NewPerson(\"女孩\",\"云小卷\") //在结构体私有时，可通过工厂夸包访问 person.int=2 //调用父类的属性 person.print()//调用父类的方法 fmt.Println(person.student.int) //当父类与子类重名时，通过类找到指定的属性或方法 } func NewPerson(tpye string,name string) *person { return \u0026person{ tpye: tpye, name: name, } } type student struct { int //匿名属性 } func (this *student) print() { this.int=3 } type person struct { tpye string \"这里是标签\" name string \"标签2\" int student //继承student类 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:31:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 结构体方法 package main import ( \"fmt\" ) type Base struct{} func (Base) Magic() { fmt.Println(\"base magic\") } func (self Base) MoreMagic() { self.Magic() self.Magic() //同一个包内的结构体属性与方法可以相互访问 } type Voodoo struct { } func (Voodoo) Magic() { fmt.Println(\"voodoo magic\") } func main() { v := new(Voodoo) v1:=\u0026Base{} v.Magic() //v.MoreMagic() v1.Magic() } 七、接口 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:32:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 类实现接口 package main import \"fmt\" func main() { var dao DAO =new(User) //创建一个类的实例，当用实例赋值给接口时，表示实现该接口 dao.findUser() //所有接口调用运行类型的方法 } type User struct { namn string } func (u *User) findAll() []User { panic(\"implement me\") } func (u *User) findUser() { fmt.Println(\"方法实现\") } type DAO interface { //查询 findUser() //定义一个抽象方法 //查询所有 findAll() []User } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:33:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1接口内嵌接口 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样 package main func main() { var simple File =new(Simple) println(simple.Write(*(new(Buffer)))) } type Simple struct { int } func (s Simple) Read(b Buffer) bool { panic(\"implement me\") } func (s Simple) Write(b Buffer) bool { return true } func (s Simple) Lock() { panic(\"implement me\") } func (s Simple) Unlock() { panic(\"implement me\") } func (s Simple) Close() { panic(\"implement me\") } type Buffer struct { } type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Lock interface { Lock() Unlock() } type File interface { ReadWrite Lock Close() } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:34:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 类型断言 package main func main() { var person person=\u0026stdunet{} person.set(32) // T, ok := varI.(T) :向下转型公式，var1必须是接口类型 if stdunet, ok := person.(*stdunet);ok{ //判断运行类型，ok为true或false，studnet是向下转型的值 println(stdunet.getInt()) } } type stdunet struct { int } func (student *stdunet) set(i int) { student.int=i } func (student *stdunet) getInt() int { return student.int } type person interface { set(int) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:35:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 tpye-switch 类型判断 package main func main() { var Simpler,Simpler2 Simpler =\u0026Simple{},\u0026RSimple{} Simpler.set(32) Simpler2.set(111) bianli(Simpler,Simpler2) } func bianli(inter ...interface{}) { for index, value := range inter { switch type1:=value.(type) { //判断type1的类型 case *Simple: println(index,type1.getInt()) //走到相应的类型，通过判断的对象调用私有属性 case *RSimple: println(index,type1.getInt()) } } } type Simple struct { int } func (this *Simple) set(i int) { this.int=i } func (this *Simple) getInt() int { return this.int } type Simpler interface { set(int) } type RSimple struct { int } func (this *RSimple) set(i int) { this.int =i } func (this *RSimple) getInt() int { return this.int } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:36:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 方法集的调用规则 在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的： 指针方法可以通过指针调用 值方法可以通过值调用 接收者是值的方法可以通过指针调用，因为指针会首先被解引用 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址 将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。 Go 语言规范定义了接口方法集的调用规则： 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 类型 T 的可调用方法集包含接受者为 T 的所有方法 package main import \"fmt\" func main() { student1 :=student{} //定义一个值对象 common(\u0026student1)//传入值对象的指针 } type student struct { } func (receiver *student) hi() { //指针方法，值对象无法调用 fmt.Println(\"hi,我是学生\") } func (student student) say() {//值方法，指针对象和值对象都可以调用 fmt.Println(\"我是学生\") } type person interface { say() hi() } func common(person2 person) {//person可以接收值类型也可以接口指针类型； person2.say() } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:37:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.5 空接口 因为任何类型都实现了空接口，所有空接口可以接收任意类型值， package main import \"fmt\" func main() { var interNil interface{} //定义一个空接口变量，可以接收任意类型 interNil = 2 fmt.Printf(\"%T\\n\",interNil) interNil =\"123\" fmt.Printf(\"%T\\n\",interNil) interNil =new(person) fmt.Printf(\"%T\\n\",interNil) interNil =[]int{12,23} fmt.Printf(\"%T\",interNil) } type person struct { } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:38:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.6 接口多态 func main() { sru1 :=new(sru) w(sru1) } type M1 interface { f() } type sru struct { } func (s sru) f() { fmt.Println(\"我是f\") } func w(m M1) { m.f() } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:39:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.7 接口的继承 当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法 八、错误处理与测试 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:40:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 定义异常 func main() { err :=errors.New(\"输入有问题吗\") //通过实现error接口的类，创建一个异常字符串 if err != nil { fmt.Println(\"有错误\") } fmt.Println(err) W:=FMTerr(\"2323\") //调用fmt错误对象函数 fmt.Println(W) } type p struct { s string } func NEW(text string)error { return \u0026p{text} } func FMTerr(text string)error { //使用fmt创建错误对象 return fmt.Errorf(\"%s\",text) } func (e *p) Error() string { return e.s } 九、协程与通道 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:41:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.0 通道的声明 通常使用这样的格式来声明通道：var identifier chan datatype 未初始化的通道的值是 nil 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序 func main() { //var identifier chan datatype var ch chan chan string //通道里面包含放string的通道 var ch1 chan string //通道里面放string var ch2 chan func() //通道里面放函数 ch1 =make(chan string) fmt.Println(ch1,ch,ch2) } ------------------------------------------------ func main() { ch := make(chan string) go func() { ch\u003c-\"1\" ch\u003c-\"1\" ch\u003c-\"1\" ; ch\u003c-\"1\" //写入数据 }() go func() { for ;; { input:=\u003c-ch //从ch取出数据， fmt.Println(input) } }() time.Sleep(2e9) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:42:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.1 有缓冲与无缓冲通道 如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。 如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:43:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.2 工厂模式返回chan package main import ( \"fmt\" \"time\" ) func main() { go pr(sum()) // time.Sleep(1e9) } func sum() chan int { //工厂模式返回chan ch :=make(chan int,10) i :=0 for i\u003c90 { i+=10 ch\u003c-i } return ch } func pr(ch chan int) {//接受者接收 for ;;{ fmt.Println(\u003c-ch) } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:44:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.3 单向通道 func main() { vCh := make(chan int, 10) go write(vCh) go read(vCh) time.Sleep(1e9) } func write(vch chan\u003c- int) { //单向通道需要开两个协程 for i := 0; i \u003c 100; i++ {//写入数据大于通道容量造成死锁 vch \u003c- i } } func read(vch \u003c-chan int) { for { fmt.Println(\u003c-vch) } } -------------------------------------- ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:45:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.4 关闭通道、判断阻塞通道 func main() { ch := make(chan string) go sendData(ch) getData(ch) } func sendData(ch chan string) { ch \u003c- \"Washington\" //放一个，取一个，未取出则阻塞，当写入最后一个时，通道关闭 ch \u003c- \"Tripoli\" ch \u003c- \"London\" ch \u003c- \"Beijing\" ch \u003c- \"Tokio\" close(ch) } func getData(ch chan string) { for { input, open := \u003c-ch //无法读取数据时，阻塞并关闭时，open返回false fmt.Println(open) if !open { break } fmt.Printf(\"%s \", input) } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:46:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.5 select切换协程 func main() { v1 :=make(chan int) v2 :=make(chan int) go p(v2) go p(v1) go se(v1,v2) time.Sleep(2e9) } func p(ch chan\u003c- int) { for i := 0; i\u003c200; i++ { ch\u003c-i } } func se(ch1,ch2 chan int ) { for { select { case v := \u003c-ch1: //当ch1无数据可读时，select阻塞等待 fmt.Println(\"111\", v) case \u003c-ch2: fmt.Println(\"222\", \u003c-ch2) } } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:47:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"1.6 通道、超时、计时器 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/:48:0","tags":null,"title":"","uri":"/posts/golang/go%E5%9F%BA%E7%A1%80%E8%BE%83%E8%AF%A6%E7%BB%86/"},{"categories":null,"content":"GIN 微服务框架搭建： go mod init 项目名 go get -u github.com/gin-gonic/gin go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 数据库链接：?charset=utf8\u0026parseTime=True\u0026loc=Local ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:0:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 接口开发 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func s(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"状态：\":http.StatusOK, \"msg\":\"hello\", }) } func main() { // 1.创建路由 r := gin.Default() // 2.绑定路由规则，执行的函数 // gin.Context，封装了request和response r.GET(\"/\",s ) r.POST(\"/hello\", func(context *gin.Context) { context.JSON(http.StatusOK,gin.H{\"状态\":http.MethodPut}) }) r.PUT(\"/\", func(context *gin.Context) { context.JSON(http.StatusOK,gin.H{\"状态\":http.MethodPut}) }) r.DELETE(\"/\", func(context *gin.Context) { context.JSON(http.StatusOK,gin.H{\"状态\":http.MethodDelete}) }) // 3.监听端口，默认在8080 // Run(\"里面不指定端口号默认为8080\") r.Run(\":8000\") } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:1:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 url传递参数 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { router := gin.Default() //1,请求带参数/user?name=23;不带参数为默认 router.GET(\"/user\", func(c *gin.Context) { query := c.DefaultQuery(\"name\", \"小花\")//带默认值的参数 name := c.Query(\"name\") //参数不输入默认值 c.JSON(http.StatusOK,gin.H{\"msg\":fmt.Sprintf(\"%s%s\",query,name)}) }) //2,请求为路径/user/2323；不带Name路径走上面一个请求，name不可省略 router.GET(\"/user/:name\", func(c *gin.Context) { name := c.Param(\"name\") c.JSON(http.StatusOK,gin.H{\"msg\":fmt.Sprintf(\"%s\",name)}) }) //3,相同路径可以用不同请求区分，否则会起冲突 router.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) }) router.POST(\"/user/:name/*action\", func(c *gin.Context) { b := c.FullPath() == \"/user/:name/*action\" // true c.String(http.StatusOK, \"%t\", b) }) //4，精确请求 router.GET(\"/groups\", func(c *gin.Context) { c.String(http.StatusOK, \"The available groups are [...]\") }) router.Run(\":8080\") } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:2:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 post表单参数 表单传输为post请求，http常见的传输格式为四种： application/json application/x-www-form-urlencoded application/xml multipart/form-data 表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.POST(\"/user\",s) //使用postman以表单参数提交 r.Run(\":8081\") //必须加:号 } func s(c *gin.Context) { username := c.PostForm(\"username\") password := c.PostForm(\"password\") //当不填写该参数时，返回为零值，不会报错 id := c.DefaultPostForm(\"id\", \"20\") //表单形式的默认参数 c.JSON(http.StatusOK,gin.H{\"username\":username,\"password\":password,\"id\":id}) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:3:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.3 query+post form //请求url：http://127.0.0.1:8081/user?usernameID=2\u0026sex=女 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.POST(\"/user\",s) //使用postman以表单参数提交 r.Run(\":8081\") //必须加:号 } func s(c *gin.Context) { userID := c.Query(\"usernameID\") sex := c.DefaultQuery(\"sex\",\"男\") //DefaultQuery必须两个参数 username := c.PostForm(\"username\") password := c.PostForm(\"password\") //当不填写该参数时，返回为零值，不会报错 id := c.DefaultPostForm(\"id\", \"20\") //表单形式的默认参数 c.JSON(http.StatusOK,gin.H{\"userid\":userID,\"username\":username,\"password\":password,\"id\":id,\"sex\":sex}) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:4:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.4 文件上传 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:5:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"单文件上传 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func main() { r := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB r.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB r.POST(\"/upload\",upload) r.Run(\":8081\") //必须加:号 } func upload(c *gin.Context) { //单文件上传 file,err := c.FormFile(\"file\") //指定从的请求头中的file字段获取文件 if err!=nil{ c.JSON(http.StatusOK,gin.H{\"msg\":err.Error()}) return } log.Println(\"文件名：\",file.Filename,\"文件大小：\",file.Size,\"请求头参数：\",file.Header) //拼接存放地址 sprintf := fmt.Sprintf(\"E:/GoProject/src/templates/%s\", file.Filename) // 上传文件到指定的目录 err = c.SaveUploadedFile(file, sprintf) if err!=nil { c.JSON(http.StatusOK,gin.H{\"msg\":err.Error()}) } c.JSON(http.StatusOK,gin.H{\"msg\":\"文件上传成功！\"}) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:5:1","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"多文件上传 package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // 多个文件上传 form, _ := c.MultipartForm() //获取标的数据 headers := form.File[\"file\"] //通过表单的file获取file的切片 for _, header := range headers { //遍历file切片 log.Println(header.Filename) sprintf := fmt.Sprintf(\"E:/GoProject/src/templates/%s\", header.Filename) c.SaveUploadedFile(header, sprintf) } // 上传文件到指定的目录 c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"%vuploaded!\", len(headers)), }) }) router.Run() } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:5:2","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.5 路由分组（支持嵌套） package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func main() { r := gin.Default() r.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB user := r.Group(\"/user\") //分组路由头；user是一个路由组对象，通过路由组创建请求 { user.POST(\"/upload\",upload) //请求url：http://127.0.0.1:8081/user/upload } user2 := r.Group(\"/user2\") //分组路由头 { user2.POST(\"/login\",login) //请求url：http://127.0.0.1:8081/user2/login } r.Run(\":8081\") //必须加:号 } func login(c *gin.Context) { username := c.PostForm(\"username\") password := c.PostForm(\"password\") c.JSON(http.StatusOK,gin.H{\"msg\":\"登陆成功\",\"username\":username,\"password\":password}) } func upload(c *gin.Context) { //单文件上传 file,err := c.FormFile(\"file\") //指定从file字段获取文件 if err!=nil{ c.JSON(http.StatusOK,gin.H{\"msg\":err.Error()}) return } log.Println(\"文件名：\",file.Filename,\"文件大小：\",file.Size,\"文件头：\",file.Header) //拼接存放地址 sprintf := fmt.Sprintf(\"E:/GoProject/src/templates/%s\", file.Filename) // 上传文件到指定的目录 err = c.SaveUploadedFile(file, sprintf) if err!=nil { c.JSON(http.StatusOK,gin.H{\"msg\":err.Error()}) } c.JSON(http.StatusOK,gin.H{\"msg\":\"文件上传成功！\"}) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:6:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.6 重定向 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func redirectBaidu(c *gin.Context) { c.Redirect(http.StatusMovedPermanently,\"https://www.baidu.com\") //站外页面重定向状态码为301 } func main() { r := gin.Default() redirect :=r.Group(\"/redirect\") { redirect.GET(\"/taobao\",redirectBaidu) redirect.GET(\"/a\", func(c *gin.Context) { //站内重定向 c.Request.URL.Path=\"/redirect/b\" //修改请求的的url,必须添加完整路径 r.HandleContext(c) //通过路由执行 }) redirect.GET(\"/b\", func(c *gin.Context) { c.JSON(http.StatusOK,gin.H{\"msg\":\"b\"}) }) } r.Run(\":8081\") //必须加:号 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:7:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.7 Any与NoRoute package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() redirect :=r.Group(\"/redirect\") { redirect.Any(\"/user\", func(c *gin.Context) { //any可以接受所有请求 switch c.Request.Method { //通过判定请求方式，走对应的请求逻辑 case http.MethodGet: c.JSON(http.StatusOK,gin.H{\"method\":\"get\"}) case http.MethodPost: c.JSON(http.StatusOK,gin.H{\"method\":\"post\"}) } }) } //无路由响应 r.NoRoute(func(c *gin.Context) { c.JSON(http.StatusNotFound,gin.H{\"msg\":\"请求有误\"}) }) r.Run(\":8081\") //必须加:号 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:8:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.8 中间件（aop） 单路由aop 路由组aop 全局aop package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\" ) func full(c *gin.Context) { fmt.Println(\"我是全局的\") c.Next() } func gruop(c *gin.Context) { if username := c.PostForm(\"username\"); len(username) == 0 { c.Abort() c.JSON(http.StatusBadRequest, gin.H{\"msg\": \"用户名不能为空\"}) return } else if password := c.PostForm(\"password\"); len(password) == 0 { c.Abort() c.JSON(http.StatusBadRequest, gin.H{\"msg\": \"密码不能为空\"}) return } c.Next() //执行下一个handlerfunc } func main() { gin.SetMode(gin.DebugMode) rotuer := gin.Default() //rotuer.Use(full) //1，注册全局中间件 user := rotuer.Group(\"/user\",gruop ) //2，路由组中间件 { user.GET(\"/:id\", func(request *gin.Context) { id := request.Param(\"id\") username := request.PostForm(\"username\") password := request.PostForm(\"password\") request.JSON(http.StatusOK, gin.H{\"状态\": http.StatusOK, \"userID\": id, \"username\": username, \"password\": password}) }) } rotuer.NoRoute(func(only *gin.Context) { //3，单路由中间件 only.Set(\"msg1\", \"你的请求有误\") only.Next() }, func(c *gin.Context) { get, _ := c.Get(\"msg1\") c.JSON(http.StatusNotFound, gin.H{\"msg\": get}) }) rotuer.Run(\":8082\") } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:9:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.9 数据绑定 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) type student struct { //字段首字母必须大写 Id string `form:\"id\" json:\"id,int\"` //tag：指定不同格式数据的请求体字段名，字符串id可接受int类型数据的序列化 Name string `form:\"Name\" json:\"name\"` //json:只支持json；form:支持query与form格式数据 Sex int `form:\"sex\" json:\"sex\"` Password string `form:\"psd\" json:\"psd\"` } func main() { router:= gin.Default() router.GET(\"/user\", func(req *gin.Context) { student :=\u0026student{} err := req.ShouldBindJSON(\u0026student) //ShouldBindJSON：用于解析json格式数据；当字段为匹配时，该字段输出零值 if err!= nil { req.JSON(http.StatusBadRequest,gin.H{\"mseg\":err.Error()}) } log.Printf(\"%#v\",student) req.JSON(http.StatusOK,gin.H{\"msg\":\"成功\",\"id\":student.Id,\"name\":student.Name,\"sex\":student.Sex,\"psd\":student.Password}) }) router.POST(\"/login\",func(req *gin.Context) { student :=\u0026student{} err := req.ShouldBind(\u0026student) //可以接受json,form,query数据 if err!= nil { req.JSON(http.StatusBadRequest,gin.H{\"mseg\":err.Error()}) } log.Printf(\"%#v\",student) req.JSON(http.StatusOK,gin.H{\"msg\":\"成功\",\"id\":student.Id,\"name\":student.Name,\"sex\":student.Sex,\"psd\":student.Password}) }) router.GET(\"/get\",func(req *gin.Context) { //get请求不能传递json数据 student :=\u0026student{} err := req.ShouldBind(\u0026student) //可以接受json,form,query数据 if err!= nil { req.JSON(http.StatusBadRequest,gin.H{\"mseg\":err.Error()}) } log.Printf(\"%#v\",student) req.JSON(http.StatusOK,gin.H{\"msg\":\"成功\",\"id\":student.Id,\"name\":student.Name,\"sex\":student.Sex,\"psd\":student.Password}) }) router.Run(\":8081\") } GORM ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:10:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 增加 type student struct { gorm.Model Age int Name string } func main() { open, err := gorm.Open(\"database\", \"root:123456@(127.0.0.1:3306)/gorm-ecx?charset=utf8mb4\") if err!=nil { panic(err) } //db.Exec(\"UPDATE orders SET shipped_at=? WHERE id IN (?)\", time.Now(), []int64{11,22,33}) open.AutoMigrate(\u0026student{}) students := student{ Model: gorm.Model{}, Age: 21, Name: \"伊莲\", } //open.Create(\u0026students) /*一,选择字段增加； a.未增加的字段在数据库中显示为null b.表明应与数据库表名一致（+s） c，字段应与数据库字段一致 d.表名错误，字段名错误，字段数量与值数量不对应，则插入失败，但不会报错 e.可使用RowsAffected检测是否插入成功 */ exec := open.Exec(\"INSERT INTO students(created_at,name,age) VALUE(?,?,?)\",time.Now(), students.Name, students.Age) println(exec.RowsAffected) /*二、全字段插入 a.值数量必须与字段数量一致 b.值的类型与字段类型不一致，则失败 */ selINT := open.Exec(\"INSERT INTO students VALUE(?,?,?,?,?,?)\", students.ID,time.Now(),time.Now(),time.Now(),students.Age,students.Name) println(selINT.RowsAffected) /*三、库内查询后增加 ：INSERT INTO table1 (column1,column2) SELECT column1,column2 FROM table2 */ } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:11:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 删除 package main import ( _ \"github.com/go-sql-driver/database\" \"github.com/jinzhu/gorm\" ) type student struct { gorm.Model Age int Name string } func main() { open, err := gorm.Open(\"database\", \"root:123456@(127.0.0.1:3306)/gorm-ecx?charset=utf8mb4\") if err!=nil { panic(err) } open.AutoMigrate(\u0026student{}) students := student{ Model: gorm.Model{}, Age: 21, Name: \"伊莲\", } //删除students表内name为某值的记录，当前代码可删除多条；where多个条件 exec := open.Exec(\"DELETE FROM students WHERE name = ? and id = ? \", students.Name,24) println(exec.RowsAffected) ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:12:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 修改 package main import ( _ \"github.com/go-sql-driver/database\" \"github.com/jinzhu/gorm\" ) type student struct { gorm.Model Age int Name string } func main() { open, err := gorm.Open(\"database\", \"root:123456@(127.0.0.1:3306)/gorm-ecx?charset=utf8mb4\") if err!=nil { panic(err) } open.AutoMigrate(\u0026student{}) students := student{ Model: gorm.Model{}, Age: 25, Name: \"小卷\", } //UPDATE 表名 SET 列1=新值1,列2=新值2 WHERE 过滤条件 //1,指定字段名，指定where条件;可以更新字段为空 exec := open.Exec(\"UPDATE students SET name =? ,age =? WHERE id =?\", students.Name, nil, 25) println(exec.RowsAffected) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:13:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.3 查询 package main import ( \"fmt\" _ \"github.com/go-sql-driver/database\" \"github.com/jinzhu/gorm\" ) type student struct { gorm.Model Age int Name string } func main() { open, err := gorm.Open(\"database\", \"root:123456@(127.0.0.1:3306)/gorm-ecx?charset=utf8mb4\") if err!=nil { panic(err) } open.AutoMigrate(\u0026student{}) students := student{} /*四、查询 a.创建一个返回类型变量，传给scan，反射到字段内 b.通过类型变量取值 */ open.Raw(\"SELECT name, age FROM students WHERE ID = ?\", 25).Scan(\u0026students) fmt.Println(students.Name,students.Age) open.First(\u0026students) fmt.Println(students) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:14:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.4 tag column 指定 db 列名 type 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INSTREMENT size 指定列大小，例如：size:256 primaryKey 指定列为主键 unique 指定列为唯一 default 指定列的默认值 precision 指定列的精度 scale 指定列大小 not null 指定列为 NOT NULL autoIncrement 指定列为自动增长 embedded 嵌套字段 embeddedPrefix 嵌入字段的列名前缀 autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建 / 更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli index 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情 uniqueIndex 与 index 相同，但创建的是唯一索引 check 创建检查约束，例如 check:age \u003e 13，查看 约束 获取详情 \u003c- 设置字段写入的权限， \u003c-:create 只创建、\u003c-:update 只更新、\u003c-:false 无写入权限、\u003c- 创建和更新权限 -\u003e 设置字段读的权限，-\u003e:false 无读权限 - 忽略该字段，- 无读写权限 rpc ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:15:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 server package main import ( \"log\" \"net/http\" \"net/rpc\" ) type M struct { H,Y int } func (this *M) Chu(M *M,reply *int) error { *reply = M.Y+M.H return nil } func main() { //1,声明一个服务 m := new(M) //2，注册服务 rpc.Register(m) //2,自定义服务名称 rpc.RegisterName(\"Mfuwu\",m) //3，将服务绑定到http协议 rpc.HandleHTTP() //4.启动监听 err := http.ListenAndServe(\"127.0.0.1:8080\", nil) if err!=nil { log.Println(err) } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:16:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 client package main import ( \"fmt\" \"net/rpc\" ) type M struct { H,Y int } func main() { http, err := rpc.DialHTTP(\"tcp\", \"127.0.0.1:8080\") if err !=nil{ panic(err) } m :=\u0026M{1,2} var name int //同步请求 err = http.Call(\"Mfuwu.Chu\", \u0026m, \u0026name) fmt.Println(name) //异步请求 call := http.Go(\"M.Chu\", \u0026m, \u0026name, nil) \u003c-call.Done //完成异步请求提示 fmt.Println(name) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:17:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 网络传输数据格式 Grpc+protobuf 下载github.com/golang/protobuf https://github.com/golang/protobuf 放到$GOPATN/src/github.com/golang目录下 安装grpc go get google.golang.org/grpc 3、安装proto ​ go get -u github.com/golang/protobuf/proto ​ go get -u github.com/golang/protobuf/protoc-gen-go 编译grpc/examples/helloworld/helloworld/下的proto文件 protoc –go_out=plugins=grpc:. .\\pkg\\admin\\proto\\admin.proto ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:18:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 编写proto文件 //定义版本号 syntax=\"proto3\"; //指定生成user.pb.gp的包名 package proto; option go_package = \"./\"; //自定文件的存储位置 //定义客户端请求的数据格式 message UserRequest{ //定义请求参数 string name =1; } //定义服务端响应的数据格式 message UserResponse{ //定义响应参数 int32 id =1; string name =2; int32 age =3; //表示可变数组，类型切片类型 repeated string hobby =4; } //service定义开放调用服务 service UserInfoService{ //定一个一个服务的方法，接受的参数，响应的参数 rpc GetUserInfo(UserRequest) returns (UserResponse){} } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:19:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 grpc客户端实现 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"log\" \"mm/MESSAGE\" ) func main() { //1,连接grpc服务,得到一个连接对象;rpc.WithInsecure():以安全的方式连接 clientConn, err := grpc.Dial(\"127.0.0.1:8081\", grpc.WithInsecure()) if err!=nil{ log.Println(err) return } defer clientConn.Close() //2,通过proto生成的文件初始化客户端 client := MESSAGE.NewUserClient(clientConn) //3，调用远程服务 requset:=\u0026MESSAGE.Request{Name: \"张三\"} //context.TODO():上下文的空对象，传入一个定义好的类型，返回respoes res, err := client.Get(context.TODO(), requset) if err!=nil{ log.Println(err) } fmt.Println(res) } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:20:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 grpc服务端 package main import ( \"context\" \"google.golang.org/grpc\" \"log\" \"mm/MESSAGE\" \"net\" ) type user1 struct { } func (u user1) Get(ctx context.Context, request *MESSAGE.Request) (*MESSAGE.Repones, error) { return \u0026MESSAGE.Repones{Name: request.Name} ,nil } func main() { //1.初始化grpc服务对象 server := grpc.NewServer() //2,注册服务;通过proto生成的注册服务方法注册；传入grpc初始化服务与实现了UserServer接口的服务对象 MESSAGE.RegisterUserServer(server,new(user1)) //3,设置监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:8081\") if err!=nil{ log.Println(err) return } defer listen.Close() //4.通过初始化的grpc对象启动grpc服务，传入监听窗口 err = server.Serve(listen) if err!=nil{ log.Println(err) return } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:21:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.3 ssl认证 安装ssl :官方下载地址： https://www.openssl.org/source/ ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:22:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.4 token认证 客户端 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"log\" \"turan.com/go_modules/proto\" ) //定义token结构体 type TokenAuthentication struct { appkey string appsecret string } //实现credentials.PerRPCCredentials接口 func (t *TokenAuthentication) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) { return map[string]string{\"AppKey\":t.appkey,\"AppSecret\":t.appsecret},nil } func (t TokenAuthentication) RequireTransportSecurity() bool { return false //基于tls进行安全认证 } func main() { //实例化token token :=\u0026TokenAuthentication{ appkey: \"0824\", appsecret: \"hello\", } req := proto.HelloReq{Name: \"1\"} //传入token，或传入ssl认证信息 client, err := grpc.Dial(\"127.0.0.1:8080\", grpc.WithInsecure(),grpc.WithPerRPCCredentials(token)) if err!=nil{ log.Println(err) } defer client.Close() helloClient := proto.NewHelloserverClient(client) res, err := helloClient.Get(context.Background(), \u0026req) if err!=nil { log.Println(\"返回错误\",err) return } fmt.Println(res.GetOrder()) } 服务端 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"google.golang.org/grpc/codes\" \"google.golang.org/grpc/metadata\" \"google.golang.org/grpc/status\" \"log\" \"net\" \"strconv\" \"turan.com/go_modules/proto\" ) type hello struct { } var m []*proto.HelloRes func (h hello) Get(ctx context.Context, req *proto.HelloReq) (*proto.HelloRes, error) { keyMap, b := metadata.FromIncomingContext(ctx) //调用FromIncomingContext，取出在请求头中的map信息，token信息携带请求头中 if !b { return nil,status.Error(codes.Unauthenticated,\"无token认证信息\") } var appkey string var appsecret string for s, strings := range keyMap { //判断一个map的key是否存在，返回value,bool log.Println(s,strings) } if value,ok := keyMap[\"appkey\"];ok{ appkey=value[0] }else { log.Println(\"appkey不存在\") } if value,ok := keyMap[\"appsecret\"];ok{ appsecret=value[0] }else { log.Println(\"AppSecret不存在\") } if appkey!=\"0824\"|| appsecret!=\"hello\" { return nil,status.Error(codes.Unauthenticated,\"token不合法\") }else { atoi, err := strconv.Atoi(req.Name) //string转int if err!=nil { return nil,status.Error(codes.Unauthenticated,\"请求数据有误\") } fmt.Println(\"返回数据\") return m[atoi], nil } } func main() { m = make([]*proto.HelloRes, 5) m = append(m, \u0026proto.HelloRes{Order: \"8\"},\u0026proto.HelloRes{Order: \"3\"}) server := grpc.NewServer() proto.RegisterHelloserverServer(server,\u0026hello{}) listen, err := net.Listen(\"tcp\", \"127.0.0.1:8080\") if err!=nil{ panic(err) } err= server.Serve(listen) if err!=nil { panic(err) } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:23:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.5 拦截器 redis import \"github.com/go-redis/redis\" //下载地址 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:24:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 get与set用法 package main import ( \"fmt\" \"github.com/go-redis/redis\" \"log\" ) func main() { client := redis.NewClient(\u0026redis.Options{ //建立连接 Network: \"tcp\", Addr: \"127.0.0.1:6379\", DB: 0, //指定redis库编号 PoolSize: 100, //连接池大小 }) defer client.Close() _, err := client.Ping().Result() //判断是否出现连接错误 if err!=nil{ log.Println(err) return } fmt.Println(\"连接成功\") result, err := client.Get(\"ww\").Result() //返回一个查询结果与错误 if err==redis.Nil { //redis.nil:为不存在 log.Println(\"name is not exist\") }else if err!=nil{ //再判断其他类型错误 log.Println(err) return }else { fmt.Println(result) // } resul2t, err := client.Set(\"token\", \"2\", 0).Result() //返回一个是成功信息，插入效果类型map，key不可以重复 if err!=nil{ log.Println(err) return } if resul2t==\"OK\" { fmt.Println(\"插入成功\") } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:25:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 批量提交 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:26:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 事务（监听值是否变化） log日志 劣势 仅限基本的日志级别 只有一个Print选项。不支持INFO/DEBUG等多个级别; 对于错误日志，它有Fatal和Panic Fatal日志通过调用os.Exit(1)来结束程序; Panic日志在写入日志消息之后抛出一个panic; 但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误 缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等; 不提供日志切割的能力; ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:27:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 日志使用 package main import ( \"log\" \"net/http\" \"os\" ) var url = \"https://www.baiu.com\" func main() { file, err := os.OpenFile(\"./log/http.log\", os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644) if err!=nil { log.Println(err) return } log.SetOutput(file) //传入一个打开的文件，指定日志的输出文件；没有设置时，log输出到终端 get, err := http.Get(url) if err!=nil { log.Printf(\"error :%v url:%s \",err,url) //将日志输出到指定的文件夹内 }else { log.Printf(\"status code:%d url:%s\",http.StatusOK,url) get.Body.Close() } } # zap日志 ​~~~go import \"go.uber.org/zap\" zap日志 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:28:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 zap日志记录器 NewProduction\u0026Sugar是内置的json格式记录形式 package main import ( \"go.uber.org/zap\" \"net/http\" ) var logger *zap.Logger var sugareLogger *zap.SugaredLogger var url =\"https://www.baidu.com\" func main() { //例如production logger默认记录调用函数信息、日期和时间等; logger, _ = zap.NewProduction()//以键值对的形式记录日子 //将prod转换成sugar日志，默认记录调用函数信息、日期和时间等 sugareLogger = logger.Sugar() //以格式化字符串的形式记录日志 sugareLogger.Debug(\"get url\",url) res, err := http.Get(url) if err!=nil{ logger.Error(\"Error fetching url..\", zap.String(\"url\",url), zap.String(\"err\",err.Error()), ) sugareLogger.Errorf(\"Error fetching URL %s : Error = %s\", url, err) }else { logger.Info(\"success\",//以键值对的形式记录日子 zap.String(\"status code\",res.Status), ) sugareLogger.Infof(\"Success! statusCode = %s for URL %s\", res.Status, url)//以格式化字符串的形式记录日志 res.Body.Close() } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:29:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 zap自定义日志 自定义日志配置默认展示：日志级别，时间; package diyzap import ( \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" \"os\" ) var SugareLogger *zap.SugaredLogger var Logger *zap.Logger //例如production logger默认记录调用函数信息、日期和时间等; func init() { encoder := getEncoder() writerFlie := getLogWriter() //new一个新配置，组装编码，输出文件路径，日志级别 core := zapcore.NewCore(encoder, writerFlie, zapcore.DebugLevel) //传入编码，输出文件，指定日志输出级别 //将配置传入给生成logger方法,zap32.AddCaller():输出函数被调用的信息 Logger = zap.New(core,zap.AddCaller()) SugareLogger = Logger.Sugar() //转换成字符串格式化类型的logger } func getEncoder() zapcore.Encoder { // encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder //添加可读时间格式 encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder //指定字符串输出的编码类型 //指定一个json格式输出日志,返回一个json格式的输出配置；encoderConfig：在json格式中添加默认展示字段 return zapcore.NewJSONEncoder(encoderConfig) //指定普通字符串格式输出日志 //return zapcore.NewConsoleEncoder(zap32.NewProductionEncoderConfig()) } func getLogWriter()zapcore.WriteSyncer { file, _ := os.OpenFile(\"./zap32/diyzap/diy.log\",os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644) return zapcore.AddSync(file) //传入一个文件句柄，指定输出文件 } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:30:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 自定义zap结合gin框架 package main import ( \"go.uber.org/zap\" \"net\" \"net/http\" \"net/http/httputil\" \"os\" \"runtime/debug\" \"strings\" \"time\" \"turan.com/go_modules/zap32/diyzap\" ) import \"github.com/gin-gonic/gin\" func main() { router := gin.New() router.Use( GinLogger(diyzap.Logger),GinRecovery(diyzap.Logger,true)) router.GET(\"/user\", func(context *gin.Context) { context.JSON(http.StatusOK,gin.H{\"msg\":\"成功\"}) }) router.Run() } //设定一个基于zap的中间件 func GinLogger(logger *zap.Logger) gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query:=c.Request.URL.RawQuery c.Next() cost :=time.Since(start) logger.Info(path, zap.Int(\"status\",c.Writer.Status()), zap.String(\"method\",c.Request.Method), zap.String(\"path\",path), zap.String(\"query\",query), zap.String(\"ip\",c.ClientIP()), zap.String(\"user-agent\",c.Request.UserAgent()), zap.String(\"errrors\",c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\"cost\",cost)) } } // GinRecovery recover掉项目可能出现的panic func GinRecovery(logger *zap.Logger, stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \"broken pipe\") || strings.Contains(strings.ToLower(se.Error()), \"connection reset by peer\") { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { logger.Error(c.Request.URL.Path, zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), ) // If the connection is dead, we can't write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { logger.Error(\"[Recovery from panic]\", zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), zap.String(\"stack\", string(debug.Stack())), ) } else { logger.Error(\"[Recovery from panic]\", zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:31:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.3 日志分割 import \"github.com/natefinch/lumberjack\" viper配置 import \"github.com/spf13/viper\" ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:32:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 优先级 显示调用set设置 （最高） 命令行参数 环境变量 配置文件 key/value存储 默认值（最低） ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:33:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 viper加载配置文件 package main import ( \"github.com/spf13/viper\" \"log\" ) func in2() { viper.Set(\"name\",\"小卷\") //设置K,V存储到viper的map中、 println(viper.GetString(\"name\")) //找配置文件方式1： viper.SetConfigName(\"config\") //指定文件名，当只有一个文件时可以单用一个 viper.SetConfigType(\"yaml\") //指定文件后缀 viper.AddConfigPath(\"config\") //在当前项目的config文件下寻找配置文件 //找配置文件方式2： viper.SetConfigFile(\"config/config.yaml\") //当前项目路径目录当文件名 //解析配置文件 err := viper.ReadInConfig() if err!=nil{ log.Println(err) return } println(viper.GetString(\"database.host\")) } func main() { in2() } mysql: host: \"127.0.0.1\" port: 3306 dbname: \"emp\" username: root password: 123456 redis: host: \"127.0.0.1\" port: 6379 db: 0 poolsize: 100 ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:34:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 yaml反序列化 package main import ( \"fmt\" \"github.com/fsnotify/fsnotify\" \"github.com/gin-gonic/gin\" \"github.com/spf13/viper\" \"log\" \"net/http\" ) type mysql struct { Host string `mapstructure:\"host\"` Port int `mapstructure:\"port\"` Dbname string `mapstructure:\"dbname\"` Username string `mapstructure:\"username\"` Password string `mapstructure:\"password\"` } var mysql1 mysql func in2() { viper.SetDefault(\"fileDir\",\"./\") viper.SetConfigFile(\"config/config.yaml\") //当前项目路径目录当文件名 //解析配置文件 err := viper.ReadInConfig() println(viper.GetString(\"database.host\")) err2 := viper.UnmarshalKey(\"database\",\u0026mysql1) //声明yaml的配置分组,反序列化不知道热加载配置 if err2!=nil { log.Println(\"erer\",err) return } fmt.Printf(\"%#v\",mysql1) viper.WatchConfig() //热加载配置 viper.OnConfigChange(func(in fsnotify.Event) { //热加载配置 log.Println(\"文件修改了\") }) } func main() { in2() router := gin.Default() router.GET(\"/user\", func(c *gin.Context) { c.JSON(http.StatusOK,gin.H{\"配置信息\":viper.GetString(\"database.dbname\")}) }) router.Run() } go_web脚手架 加载配置文件 settings目录：创建settings.go与yaml yaml内容： 项目：名称，环境，端口 日志：日志等级，logfilname，单日志文件最大的容量，最大存储天数，备份数量 mysql：主机，端口，用户名，密码，数据库名 redis：主机，端口，数据库编号，密码 settings.go: 读取yaml配置信息 初始化日志 初始化mysql连接 初始化redis连接 注册路由 启动服务（优雅关机） bluebull ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:35:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.0 snowflake算法 生成id import \"github.com/bwmarrin/snowflake\" ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:36:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.1 validator参数校验库 https://pkg.go.dev/github.com/go-playground/validator#hdr-Baked_In_Validators_and_Tags package utils import ( \"fmt\" \"github.com/gin-gonic/gin/binding\" \"github.com/go-playground/locales/en\" \"github.com/go-playground/locales/zh\" ut \"github.com/go-playground/universal-translator\" \"github.com/go-playground/validator/v10\" enTranslations \"github.com/go-playground/validator/v10/translations/en\" zhTranslations \"github.com/go-playground/validator/v10/translations/zh\" ) // 定义一个全局翻译器T var trans ut.Translator // InitTrans 初始化翻译器 func InitTrans(locale string) (err error) { // 修改gin框架中的Validator引擎属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok { zhT := zh.New() // 中文翻译器 enT := en.New() // 英文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(enT, zhT, enT) // locale 通常取决于 http 请求头的 'Accept-Language' var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 trans, ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(\"uni.GetTranslator(%s) failed\", locale) } // 注册翻译器 switch locale { case \"en\": err = enTranslations.RegisterDefaultTranslations(v, trans) case \"zh\": err = zhTranslations.RegisterDefaultTranslations(v, trans) default: err = enTranslations.RegisterDefaultTranslations(v, trans) } return } return } ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:37:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"},{"categories":null,"content":"1.2 jwt import \"github.com/dgrijalva/jwt-go\" Token: 头部:用户信息 负载:官方字段 签名:加密信息 package utils import ( \"errors\" \"github.com/dgrijalva/jwt-go\" \"log\" \"time\" \"turan.com/web_demo/models\" ) const TokenExpirDuration = time.Hour * 2 //定义过期时间 var MySercet = []byte(\"turan\") //定义加密密钥 type Myclaims struct { UserID int64 `json:\"user_id\"` UserName string `json:\"user_name\"` jwt.StandardClaims //包含官方字段 } //生成token func GetToken(user *models.User) (string, error) { c := Myclaims{ UserID: user.UserID, UserName: user.UserName, StandardClaims: jwt.StandardClaims{ ExpiresAt: time.Now().Add(TokenExpirDuration).Unix(), //指定token过期时间 Issuer: \"turan\", }, } Token := jwt.NewWithClaims(jwt.SigningMethodHS256, c) return Token.SignedString(MySercet) } //解析token func ParamsToken(tokenString string) (*Myclaims, error) { var mc = new(Myclaims) //存放token解析后的数据 token, err := jwt.ParseWithClaims(tokenString, mc, func(token *jwt.Token) (interface{}, error) { return MySercet, nil }) if err != nil { log.Println(err.Error()) return nil, err } if token.Valid { //校验token return mc, nil } return nil, errors.New(\"invalid token\") } 1.3 swagger go get -u github.com/swaggo/swag/cmd/swag ","date":"0001-01-01","objectID":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/:38:0","tags":null,"title":"","uri":"/posts/golang/go%E5%BE%AE%E6%9C%8D%E5%8A%A11/"}]